import type { Wish } from "Wish"
import type { SideEffect } from "SideEffect"
import type { Data } from "Data"
import type { CommandError } from "System"

import { mapRej } from "Wish"
import { fromWish } from "SideEffect"
import { always } from "Function"
import { andDo } from "Monad"
import { Response } from "Http"

import type { Dependency } from "./Dependency"
import type { Config } from "./Config"

import Constants from "./Constants"



export type DownloadResult
  = Downloaded(Dependency)
  | DownloadError(String)



cleanUp :: Config -> String -> Wish CommandError String
cleanUp = (config, sanitizedUrl) => pipe(
  (url) => `rm -r ${Constants.TEMPORARY_MODULES_PATH}${url}.zip ${Constants.TEMPORARY_MODULES_PATH}${url}-tmp`,
  config.exec
)(sanitizedUrl)


copyPackageToTmpRoot :: Config -> String -> Wish CommandError String
copyPackageToTmpRoot = (config, sanitizedUrl) => pipe(
  (url) => `cp -R ${Constants.TEMPORARY_MODULES_PATH}${url}-tmp/${url} ${Constants.TEMPORARY_MODULES_PATH}`,
  config.exec
)(sanitizedUrl)


unzipPkg :: Config -> String -> Wish CommandError String
unzipPkg = (config, sanitizedUrl) => pipe(
  (url) => `unzip -d ${Constants.TEMPORARY_MODULES_PATH}${url}-tmp ${Constants.TEMPORARY_MODULES_PATH}${url}.zip`,
  config.exec
)(sanitizedUrl)


renameInnerFolder :: Config -> String -> Wish CommandError String
renameInnerFolder = (config, sanitizedUrl) => pipe(
  (url) => `mv ${Constants.TEMPORARY_MODULES_PATH}${url}-tmp/* ${Constants.TEMPORARY_MODULES_PATH}${url}-tmp/${url}`,
  config.exec
)(sanitizedUrl)


extractArchive :: Config -> String -> Wish String String
extractArchive = (config, sanitizedUrl) => pipe(
  unzipPkg(config),
  andDo(renameInnerFolder(config, sanitizedUrl)),
  andDo(copyPackageToTmpRoot(config, sanitizedUrl)),
  andDo(cleanUp(config, sanitizedUrl)),
  mapRej(always("Error processing archive"))
)(sanitizedUrl)


getPackageData :: Config -> String -> Wish String Data
getPackageData = (config, url) => pipe(
  config.get,
  map(where { Response({ data }) => data }),
  mapRej(always("Could not download package"))
)(url)


downloadPackage :: Config -> Dependency -> SideEffect DownloadResult
downloadPackage = (config, dependency) => pipe(
  .url,
  getPackageData(config),
  chain(config.writeFile(`${Constants.TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}.zip`)),
  andDo(extractArchive(config, dependency.sanitizedUrl)),
  andDo(of(Downloaded(dependency))),
  fromWish(always(DownloadError(`Package from '${dependency.url}' failed to be downloaded`)))
)(dependency)


downloadIfNotCached :: Config -> Dependency -> SideEffect DownloadResult
export downloadIfNotCached = (config, dependency) => pipe(
  (dep) => config.exists(`${Constants.TEMPORARY_MODULES_PATH}${dep.sanitizedUrl}`),
  map(always(true)),
  fromWish(always(false)),
  chain(
    (alreadyDownloaded) => alreadyDownloaded
      ? of(Downloaded(dependency))
      : downloadPackage(config, dependency)
  )
)(dependency)
