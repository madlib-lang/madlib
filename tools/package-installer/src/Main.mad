import type { Wish } from "Wish"
import L from "List"
import { chainRej, mapRej, parallel, fulfill } from "Wish"
import IO from "IO"
import Http from "Http"
import { readFile, writeFile, exists, readDir } from "FileSystem"
import J from "Json"
import Either from "Either"
import { Just, Nothing, fromMaybe } from "Maybe"
import S from "System"
import T from "Tuple"
import { always, identity, ifElse } from "Function"
import { andDo } from "Monad"
import { TextData } from "Data"

import type { Context } from "./Context"
import type { Dependency } from "./Dependency"
import type { MadlibDotJson } from "./MadlibDotJson"
import type { ValidationResult } from "./Validate"
import { initialContext } from "./Context"
import { dependencyParser } from "./Dependency"
import { load } from "./MadlibDotJson"
import { validateVersion } from "./Validate"


MADLIB_NOT_FOUND = "The madlib.json file was not found, verify that you have created one or that you run the command from the right directory."
MADLIB_MODULES_PATH = "./madlib_modules/"
TEMPORARY_MODULES_PATH = ".tmp_modules/"

moveToMadlibModules :: String -> Wish S.CommandError String
moveToMadlibModules = pipe(
  (archivePath) => `mv ${archivePath} ${MADLIB_MODULES_PATH}`,
  S.exec
)

unzipPkg :: String -> Wish S.CommandError String
unzipPkg = pipe(
  (url) => `unzip -d ${TEMPORARY_MODULES_PATH}${url}-tmp ${TEMPORARY_MODULES_PATH}${url}.zip`,
  S.exec
)

renameInnerFolder :: String -> Wish S.CommandError String
renameInnerFolder = pipe(
  (url) => `mv ${TEMPORARY_MODULES_PATH}${url}-tmp/* ${TEMPORARY_MODULES_PATH}${url}-tmp/${url}`,
  S.exec
)

copyPackageToTmpRoot :: String -> Wish S.CommandError String
copyPackageToTmpRoot = pipe(
  (url) => `cp -R ${TEMPORARY_MODULES_PATH}${url}-tmp/${url} ${TEMPORARY_MODULES_PATH}`,
  S.exec
)

copyPackageToMadlibModules :: Dependency -> Wish S.CommandError String
copyPackageToMadlibModules = pipe(
  (dependency) => ({
    destination: `${MADLIB_MODULES_PATH}${fromMaybe("", dependency.name)}`,
    source: `${TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}/`
  }),
  (paths) => `cp -R ${paths.source} ${paths.destination}`,
  S.exec
)

cleanUp :: String -> Wish S.CommandError String
cleanUp = pipe(
  (url) => `rm -r ${TEMPORARY_MODULES_PATH}${url}.zip ${TEMPORARY_MODULES_PATH}${url}-tmp`,
  S.exec
)


getDependencies :: String -> Wish String (List Dependency)
getDependencies = pipe(
  J.parse(dependencyParser),
  where {
    Either.Left(_) => of([])

    Either.Right(a) => of(a)
  }
)

displayPackagesToInstall :: List <String, String> -> List <String, String>
displayPackagesToInstall = (pkgs) => pipe(
  map(pipe(T.fst, mappend("  - "))),
  mappend(["Packages to install:"]),
  L.unlines,
  (x) => L.len(pkgs) > 0 ? IO.log(x) : x,
  always(pkgs)
)(pkgs)

extractArchive :: String -> Wish String String
extractArchive = (url) => pipe(
  unzipPkg,
  andDo(renameInnerFolder(url)),
  andDo(copyPackageToTmpRoot(url)),
  andDo(cleanUp(url)),
  mapRej(always("Error processing archive"))
)(url)


installNodeModules :: String -> Wish String String
installNodeModules = (pkgName) => pipe(
  (name) => `${MADLIB_MODULES_PATH}${name}/`,
  (path) => exists(`${path}package.json`) |> andDo(of(path)),
  map(mappend("npm install ")),
  chain(pipe(S.exec, mapRej(S.getCommandErrorMessage))),
  map((x) => IO.log(`nodejs modules installed for '${pkgName}'`) |> always(x)),
  chainRej((_) => of(IO.log(`No node modules to install for '${pkgName}'`)))
)(pkgName)

initMadlibModulesFolder :: String -> a -> Wish String a
initMadlibModulesFolder = (path, a) => pipe(
  (p) => S.exec(`mkdir -p ${p}`),
  mapRej(where { S.CommandError(_, msg) => msg }),
  andDo(of(a))
)(path)


downloadPackage :: Dependency -> Wish String Dependency
downloadPackage = (dependency) => pipe(
  .url,
  Http.get,
  map(where { Http.Response({ data }) => data }),
  mapRej(always(`Package from "${dependency.url}" failed to be downloaded`)),
  chain(writeFile(`${TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}.zip`)),
  andDo(extractArchive(dependency.sanitizedUrl)),
  andDo(of(dependency))
)(dependency)


readMadlibJSON :: Dependency -> Wish String MadlibDotJson
readMadlibJSON = (dependency) =>
  load(`${TEMPORARY_MODULES_PATH}/${dependency.sanitizedUrl}/madlib.json`)

printSuccess :: ValidationResult -> ValidationResult
printSuccess = (validationResult) => {
  where(validationResult) {
    { dependency: { name: Just(n) }} =>
    IO.log(`Package ${n} was successfully installed`)

    _ =>
      IO.log(`Package downloaded from ${validationResult.dependency.url} was successfully installed`)
  }

  return validationResult
}


processPostValidation :: ValidationResult -> Wish String ValidationResult
processPostValidation = (validationResult) => pipe(
  ifElse(
    .shouldCopy,
    pipe(
      always(copyPackageToMadlibModules(validationResult.dependency)),
      andDo(of(validationResult))
    ),
    always(of(validationResult))
  ),
  mapRej((commandError) => pipe(
    always(validationResult),
    .dependency,
    .name,
    where {
      Just(n) => `Failed post-processing ${n}\n${S.getCommandErrorMessage(commandError)}`

      Nothing => `Failed post-processing package downloaded from "${validationResult.dependency.url}"\n${S.getCommandErrorMessage(commandError)}`
    }
  )(commandError))
)(validationResult)

processDependency :: <Context, List Dependency> -> Dependency -> Wish String <Context, List Dependency>
processDependency = (contextAndNextDeps, dependency) => pipe(
  readMadlibJSON,
  map(validateVersion(T.fst(contextAndNextDeps), dependency)),
  chain(processPostValidation),
  map(printSuccess),
  map((validationResult) => validationResult.shouldCopy
    ? <
        validationResult.context,
        mappend(
          T.snd(contextAndNextDeps),
          fromMaybe([], validationResult.madlibDotJson.dependencies)
        )
      >
    : <validationResult.context, T.snd(contextAndNextDeps)>
  )
)(dependency)

processDependencies :: Context -> List Dependency -> Wish String <Context, List Dependency>
processDependencies = (context, dependencies) => pipe(
  pipe(map(downloadPackage), parallel),
  chain(L.reduceM(processDependency, <context, []>)),
  chain(where {
    <_context, []> => of(<_context, []>)

    <_context, nextDependencies> => processDependencies(_context, nextDependencies)
  })
)(dependencies)


installPackages :: Context -> Boolean -> String -> Wish String (List String)
installPackages = (context, firstLevel, madlibDotJsonPath) => pipe(
  readFile,
  mapRej(always(MADLIB_NOT_FOUND)),
  chain(initMadlibModulesFolder(MADLIB_MODULES_PATH)),
  chain(getDependencies),
  chain(processDependencies(context)),
  andDo(readDir(MADLIB_MODULES_PATH)),
  chain(pipe(map(installNodeModules), parallel)),
  map(always([""]))
)(madlibDotJsonPath)


/**
 * prepare runs before everything and takes care of creating a temporary folder
 * as well as reading and saving the content of the package.json file in-memory
 * in order to restore it at it end
 */
prepare :: String -> Wish String String
prepare = (packageDotJsonPath) => pipe(
  always(S.exec(`mkdir -p ${TEMPORARY_MODULES_PATH}`)),
  andDo(of(packageDotJsonPath)),
  mapRej(S.getCommandErrorMessage),
  chain(exists),
  chain(readFile)
)(packageDotJsonPath)


IO.log("Installing dependencies ...")

pipe(
  prepare,
  fulfill(
    (_) => pipe(
      installPackages(initialContext, true),
      fulfill(IO.log, identity)
    )("madlib.json"),
    (packageDotJsonContent) => pipe(
      installPackages(initialContext, true),
      chain((x) => writeFile("package.json", TextData(packageDotJsonContent)) |> andDo(of(x))),
      fulfill(IO.log, identity)
    )("madlib.json")
  )
)("package.json")
