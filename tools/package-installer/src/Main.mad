import type { Wish } from "Wish"
import List from "List"
import { bichain, chainRej, mapRej, parallel, fulfill } from "Wish"
import IO from "IO"
import { readFile, writeFile, exists, readDir } from "FileSystem"
import Json from "Json"
import Either from "Either"
import { Just, Nothing, fromMaybe } from "Maybe"
import System from "System"
import Tuple from "Tuple"
import { always, identity, ifElse, not } from "Function"
import { andDo } from "Monad"
import { TextData } from "Data"

import type { Context } from "./Context"
import type { Dependency } from "./Dependency"
import type { MadlibDotJson } from "./MadlibDotJson"
import type { ValidationResult } from "./Validate"
import { addInstalledPackage, hasPackageBeenInstalled, initialContext } from "./Context"
import { dependencyParser } from "./Dependency"
import { load } from "./MadlibDotJson"
import { validateVersion } from "./Validate"
import Constants from "./Constants"
import { downloadIfNotCached } from "./Download"



copyPackageToMadlibModules :: Dependency -> Wish System.CommandError String
copyPackageToMadlibModules = pipe(
  (dependency) => ({
    destination: `${Constants.MADLIB_MODULES_PATH}${fromMaybe("", dependency.name)}`,
    source: `${Constants.TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}/`
  }),
  (paths) => `cp -R ${paths.source} ${paths.destination}`,
  System.exec
)


getDependencies :: String -> Wish String (List Dependency)
getDependencies = pipe(
  Json.parse(dependencyParser),
  where {
    Either.Left(_) => of([])

    Either.Right(a) => of(a)
  }
)


installNodeModules :: String -> Wish String String
installNodeModules = (pkgName) => pipe(
  (name) => `${Constants.MADLIB_MODULES_PATH}${name}/`,
  (path) => exists(`${path}package.json`) |> andDo(of(path)),
  map(mappend("npm install ")),
  chain(pipe(System.exec, mapRej(System.getCommandErrorMessage))),
  map((x) => IO.log(`nodejs modules installed for '${pkgName}'`) |> always(x)),
  chainRej((_) => of(IO.log(`No node modules to install for '${pkgName}'`)))
)(pkgName)


initMadlibModulesFolder :: String -> a -> Wish String a
initMadlibModulesFolder = (path, a) => pipe(
  (p) => System.exec(`mkdir -p ${p}`),
  mapRej(where { System.CommandError(_, msg) => msg }),
  andDo(of(a))
)(path)


readMadlibJSON :: Dependency -> Wish String MadlibDotJson
readMadlibJSON = (dependency) =>
  load(`${Constants.TEMPORARY_MODULES_PATH}/${dependency.sanitizedUrl}/madlib.json`)


printSuccess :: ValidationResult -> ValidationResult
printSuccess = (validationResult) => {
  where(validationResult) {
    { dependency: { name: Just(n) }} =>
      IO.log(`Package ${n} was successfully installed`)

    _ =>
      IO.log(`Package downloaded from ${validationResult.dependency.url} was successfully installed`)
  }

  return validationResult
}


processPostValidation :: ValidationResult -> Wish String ValidationResult
processPostValidation = (validationResult) => pipe(
  ifElse(
    .shouldCopy,
    pipe(
      always(copyPackageToMadlibModules(validationResult.dependency)),
      andDo(of(validationResult))
    ),
    always(of(validationResult))
  ),
  mapRej((commandError) => pipe(
    always(validationResult),
    .dependency,
    .name,
    where {
      Just(n) => `Failed post-processing ${n}\n${System.getCommandErrorMessage(commandError)}`

      Nothing => `Failed post-processing package downloaded from "${validationResult.dependency.url}"\n${System.getCommandErrorMessage(commandError)}`
    }
  )(commandError))
)(validationResult)


processDependency :: <Context, List Dependency> -> Dependency -> Wish String <Context, List Dependency>
processDependency = (contextAndNextDeps, dependency) => pipe(
  readMadlibJSON,
  map(validateVersion(Tuple.fst(contextAndNextDeps), dependency)),
  chain(processPostValidation),
  map((validationResult) => where(validationResult) {
    { warning: Just(x) } => IO.log(x) |> always(validationResult)

    _ => validationResult
  }),
  map(pipe(
    printSuccess,
    (validationResult) => ({
      ...validationResult,
      context: addInstalledPackage(dependency.sanitizedUrl, validationResult.context)
    }),
    (validationResult) => validationResult.shouldCopy
      ? <
          validationResult.context,
          mappend(
            Tuple.snd(contextAndNextDeps),
            fromMaybe([], validationResult.madlibDotJson.dependencies)
          )
        >
      : <validationResult.context, Tuple.snd(contextAndNextDeps)>
  ))
)(dependency)


filterAlreadyInstalledDependencies :: Context -> List Dependency -> List Dependency
filterAlreadyInstalledDependencies = (context, dependencies) => List.filter(
  pipe(
    .sanitizedUrl,
    hasPackageBeenInstalled($, context),
    not
  )
)(dependencies)


processDependencies :: Context -> List Dependency -> Wish String <Context, List Dependency>
processDependencies = (context, dependencies) => pipe(
  filterAlreadyInstalledDependencies(context),
  pipe(map(downloadIfNotCached), parallel),
  chain(List.reduceM(processDependency, <context, []>)),
  chain(
    where {
      <_context, []> =>
        of(<_context, []>)

      <_context, nextDependencies> =>
        processDependencies(_context, nextDependencies)
    }
  )
)(dependencies)


installPackages :: Context -> String -> Wish String (List String)
installPackages = (context, madlibDotJsonPath) => pipe(
  readFile,
  mapRej(always(Constants.MADLIB_NOT_FOUND)),
  chain(initMadlibModulesFolder(Constants.MADLIB_MODULES_PATH)),
  chain(getDependencies),
  chain(processDependencies(context)),
  andDo(readDir(Constants.MADLIB_MODULES_PATH)),
  chain(pipe(map(installNodeModules), parallel)),
  map(always([""]))
)(madlibDotJsonPath)


/**
 * prepare runs before everything and takes care of creating a temporary folder
 * as well as reading and saving the content of the package.json file in-memory
 * in order to restore it at it end
 */
prepare :: String -> Wish String String
prepare = (packageDotJsonPath) => pipe(
  always(System.exec(`mkdir -p ${Constants.TEMPORARY_MODULES_PATH}`)),
  andDo(of(packageDotJsonPath)),
  mapRej(System.getCommandErrorMessage),
  chain(exists),
  chain((path) => pipe(
    System.exec,
    mapRej(System.getCommandErrorMessage),
    andDo(of(path))
  )("npm i")),
  chain(readFile)
)(packageDotJsonPath)


IO.log("Installing dependencies ...")

pipe(
  prepare,
  bichain(
    pipe(always("madlib.json"), installPackages(initialContext)),
    (packageDotJsonContent) => pipe(
      installPackages(initialContext),
      chain((x) => writeFile("package.json", TextData(packageDotJsonContent)) |> andDo(of(x)))
    )("madlib.json")
  ),
  fulfill(IO.log, identity)
)("package.json")
