import type { Wish } from "Wish"
import type { SideEffect } from "SideEffect"
import type { Maybe } from "Maybe"

import List from "List"
import { bad, bichain, chainRej, mapRej, parallel, fulfill } from "Wish"
import { execute, fromWish, toWish } from "SideEffect"
import IO from "IO"
import { readFile, writeFile, exists, readDir } from "FileSystem"
import Json from "Json"
import Either from "Either"
import { Just, Nothing, fromMaybe } from "Maybe"
import System from "System"
import Tuple from "Tuple"
import { always, identity, ifElse, not } from "Function"
import { andDo } from "Monad"
import { TextData } from "Data"


import type { Context } from "./Context"
import type { Dependency } from "./Dependency"
import type { MadlibDotJson } from "./MadlibDotJson"
import type { VersionDotLock } from "./VersionDotLock"
import type { ValidationInput, ValidationOutput, ValidationResult, Warning } from "./Validate"

import { addInstalledPackage, hasPackageBeenInstalled, initialContext } from "./Context"
import { dependencyParser } from "./Dependency"
import MadlibDotJson from "./MadlibDotJson"
import VersionDotLock from "./VersionDotLock"
import {
  validate,
  Validated,
  NotGood,
  OutOfRangeVersion,
  InvalidVersionHash,
  InvalidBuildHash
} from "./Validate"
import Constants from "./Constants"
import { downloadIfNotCached, Downloaded, DownloadError } from "./Download"
import { hashVersion } from "./Hash"



copyPackageToMadlibModules :: Dependency -> Wish System.CommandError String
copyPackageToMadlibModules = pipe(
  (dependency) => ({
    destination: `${Constants.MADLIB_MODULES_PATH}${fromMaybe("", dependency.name)}`,
    source: `${Constants.TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}/`
  }),
  (paths) => `cp -R ${paths.source} ${paths.destination}`,
  System.exec
)


getDependencies :: String -> Wish () (List Dependency)
getDependencies = pipe(
  Json.parse(dependencyParser),
  where {
    Either.Left(_) => of([])

    Either.Right(a) => of(a)
  }
)


installNodeModules :: String -> Wish () String
installNodeModules = (pkgName) => pipe(
  (name) => `${Constants.MADLIB_MODULES_PATH}${name}/`,
  (path) => exists(`${path}package.json`) |> andDo(of(path)),
  map(mappend("npm install ")),
  chain(pipe(System.exec, mapRej(System.getCommandErrorMessage))),
  map((x) => IO.log(`nodejs modules installed for '${pkgName}'`) |> always(x)),
  chainRej((_) => of(IO.log(`No node modules to install for '${pkgName}'`)))
)(pkgName)


initMadlibModulesFolder :: String -> a -> Wish String a
initMadlibModulesFolder = (path, a) => pipe(
  (p) => System.exec(`mkdir -p ${p}`),
  mapRej(where { System.CommandError(_, msg) => msg }),
  andDo(of(a))
)(path)


projectBaseUrl :: Dependency -> String
projectBaseUrl = (dependency) =>
  `${Constants.TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}`


readMadlibDotJson :: Dependency -> Wish String MadlibDotJson
readMadlibDotJson = (dependency) => MadlibDotJson.load(
  `${projectBaseUrl(dependency)}/madlib.json`
)


readVersionDotLock :: Dependency -> Wish String (Maybe VersionDotLock)
readVersionDotLock = (dependency) => pipe(
  (d) => VersionDotLock.load(`${projectBaseUrl(d)}/version.lock`),
  map(Just),
  chainRej((err) => {
    IO.log(`The package downloaded from: '${IO.grey(dependency.url)}' does not contain a version.lock file. I do not recommend using it as it means that it has not been packaged correctly and version information is corrupted. You should try to contact the package author or find another package that provides a similar affordance.`)
    return of(Nothing)
  })
)(dependency)


computeBuildHash :: Dependency -> Wish String String
computeBuildHash = (dependency) => pipe(
  (dep) => System.exec(
    `madlib package generate-hash -i ${projectBaseUrl(dep)}`
  ),
  mapRej(System.getCommandErrorMessage)
)(dependency)


prepareValidationInput :: Dependency -> Wish String ValidationInput
prepareValidationInput = (dependency) => pipe(
  readVersionDotLock,
  map((versionDotLock, computedBuildHash, madlibDotJson) => ({
    madlibDotJson,
    versionDotLock,
    computedVersionHash: hashVersion(madlibDotJson.version),
    computedBuildHash
  })),
  ap($, computeBuildHash(dependency)),
  ap($, readMadlibDotJson(dependency))
)(dependency)


printSuccess :: ValidationOutput -> ValidationOutput
printSuccess = (validationOutput) => {
  where(validationOutput) {
    { dependency: { name: Just(n) }} =>
      IO.log(IO.green(`Package ${n} was successfully installed`))

    _ =>
      IO.log(IO.green(`Package downloaded from ${validationOutput.dependency.url} was successfully installed`))
  }

  return validationOutput
}


copyPackageFromTmp :: ValidationOutput -> Wish String ValidationOutput
copyPackageFromTmp = (validationOutput) => pipe(
  ifElse(
    .shouldCopy,
    pipe(
      always(copyPackageToMadlibModules(validationOutput.dependency)),
      andDo(of(validationOutput))
    ),
    always(of(validationOutput))
  ),
  mapRej((commandError) => pipe(
    always(validationOutput),
    .dependency,
    .name,
    where {
      Just(n) => `Failed post-processing ${n}\n${System.getCommandErrorMessage(commandError)}`

      Nothing => `Failed post-processing package downloaded from "${validationOutput.dependency.url}"\n${System.getCommandErrorMessage(commandError)}`
    }
  )(commandError))
)(validationOutput)


printWarning :: a -> Warning -> a
printWarning = (a, warning) => where(warning) {
  OutOfRangeVersion =>
    IO.logAndPass(IO.yellow("Package version does not match constraints"), a)

  InvalidVersionHash =>
    IO.logAndPass(IO.yellow("Package version hash is corrupted"), a)

  InvalidBuildHash(pkgName) =>
    IO.logAndPass(
      IO.yellow(`Build hash is corrupted for package '${pkgName}'`),
      a
    )
}


processValidationResult :: ValidationResult ValidationOutput -> ValidationOutput
processValidationResult = where {
  Validated(a) =>
    a

  NotGood(warnings, a) =>
    List.reduce(printWarning, a, warnings)
}


processDependency :: <Context, List Dependency> -> Dependency -> Wish () <Context, List Dependency>
processDependency = (contextAndNextDeps, dependency) => pipe(
  prepareValidationInput,
  chain(
    pipe(
      validate(Tuple.fst(contextAndNextDeps), dependency),
      processValidationResult,
      copyPackageFromTmp
    )
  ),
  map(
    pipe(
      printSuccess,
      (validationResult) => ({
        ...validationResult,
        context: addInstalledPackage(dependency.sanitizedUrl, validationResult.context)
      }),
      (validationResult) => validationResult.shouldCopy
        ? <
            validationResult.context,
            mappend(
              Tuple.snd(contextAndNextDeps),
              fromMaybe([], validationResult.madlibDotJson.dependencies)
            )
          >
        : <validationResult.context, Tuple.snd(contextAndNextDeps)>
    )
  ),
  map(IO.logAndPass("")),
  chainRej(pipe(IO.red, IO.logAndPass($, of(contextAndNextDeps))))
)(dependency)


filterAlreadyInstalledDependencies :: Context -> List Dependency -> List Dependency
filterAlreadyInstalledDependencies = (context, dependencies) => List.filter(
  pipe(
    .sanitizedUrl,
    hasPackageBeenInstalled($, context),
    not
  )
)(dependencies)


processDependencies :: Context -> List Dependency -> Wish () <Context, List Dependency>
processDependencies = (context, dependencies) => pipe(
  filterAlreadyInstalledDependencies(context),
  pipe(
    map(downloadIfNotCached),
    parallel
  ),
  map(
    pipe(
      List.filter(where {
        DownloadError(err) => IO.logAndPass(IO.red(`${err}\n`), false)

        Downloaded(_) => true
      }),
      map(where {
        Downloaded(a) => a
      })
    )
  ),
  chain(List.reduceM(processDependency, <context, []>)),
  chain(
    where {
      <_context, []> =>
        of(<_context, []>)

      <_context, nextDependencies> =>
        processDependencies(_context, nextDependencies)
    }
  )
)(dependencies)


installedDependencyFolders :: Wish () (List String)
installedDependencyFolders = pipe(
  readDir,
  mapRej(always(()))
)(Constants.MADLIB_MODULES_PATH)


installPackages :: Context -> String -> SideEffect (List String)
installPackages = (context, madlibDotJsonPath) => pipe(
  readFile,
  mapRej(always(Constants.MADLIB_NOT_FOUND)),
  chain(initMadlibModulesFolder(Constants.MADLIB_MODULES_PATH)),
  bichain(always(bad(())), pipe(
    getDependencies,
    chain(processDependencies(context)),
    andDo(installedDependencyFolders),
    chain(pipe(map(installNodeModules), parallel))
  )),
  fromWish(always([]))
)(madlibDotJsonPath)


/**
 * prepare runs before everything and takes care of creating a temporary folder
 * as well as reading and saving the content of the package.json file in-memory
 * in order to restore it at it end
 */
prepare :: String -> Wish String String
prepare = (packageDotJsonPath) => pipe(
  always(System.exec(`mkdir -p ${Constants.TEMPORARY_MODULES_PATH}`)),
  andDo(of(packageDotJsonPath)),
  mapRej(System.getCommandErrorMessage),
  chain(exists),
  chain((path) => pipe(
    System.exec,
    mapRej(System.getCommandErrorMessage),
    andDo(of(path))
  )("npm i")),
  chain(readFile)
)(packageDotJsonPath)


restorePackageDotJson :: String -> Wish () String
restorePackageDotJson = pipe(
  (content) => writeFile("package.json", TextData(content)),
  mapRej(always(()))
)


IO.log("Installing dependencies ...")

pipe(
  prepare,
  bichain(
    pipe(always("madlib.json"), installPackages(initialContext), toWish),
    (packageDotJsonContent) => pipe(
      installPackages(initialContext),
      toWish,
      chain((x) => restorePackageDotJson(packageDotJsonContent) |> andDo(of(x)))
    )("madlib.json")
  ),
  fulfill(IO.log, identity)
)("package.json")
