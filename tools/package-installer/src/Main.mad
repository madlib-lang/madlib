import type { Wish } from "Wish"
import type { Maybe } from "Maybe"

import List from "List"
import { bichain, chainRej, mapRej, parallel, fulfill } from "Wish"
import IO from "IO"
import { readFile, writeFile, exists, readDir } from "FileSystem"
import Json from "Json"
import Either from "Either"
import { Just, Nothing, fromMaybe } from "Maybe"
import System from "System"
import Tuple from "Tuple"
import { always, identity, ifElse, not } from "Function"
import { andDo } from "Monad"
import { TextData } from "Data"


import type { Context } from "./Context"
import type { Dependency } from "./Dependency"
import type { MadlibDotJson } from "./MadlibDotJson"
import type { VersionDotLock } from "./VersionDotLock"
import type { ValidationInput, ValidationOutput, ValidationResult, Warning } from "./Validate"

import { addInstalledPackage, hasPackageBeenInstalled, initialContext } from "./Context"
import { dependencyParser } from "./Dependency"
import MadlibDotJson from "./MadlibDotJson"
import VersionDotLock from "./VersionDotLock"
import {
  validate,
  Validated,
  NotGood,
  OutOfRangeVersion,
  InvalidVersionHash,
  InvalidBuildHash
} from "./Validate"
import Constants from "./Constants"
import { downloadIfNotCached } from "./Download"
import { hashVersion } from "./Hash"



copyPackageToMadlibModules :: Dependency -> Wish System.CommandError String
copyPackageToMadlibModules = pipe(
  (dependency) => ({
    destination: `${Constants.MADLIB_MODULES_PATH}${fromMaybe("", dependency.name)}`,
    source: `${Constants.TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}/`
  }),
  (paths) => `cp -R ${paths.source} ${paths.destination}`,
  System.exec
)


getDependencies :: String -> Wish String (List Dependency)
getDependencies = pipe(
  Json.parse(dependencyParser),
  where {
    Either.Left(_) => of([])

    Either.Right(a) => of(a)
  }
)


installNodeModules :: String -> Wish String String
installNodeModules = (pkgName) => pipe(
  (name) => `${Constants.MADLIB_MODULES_PATH}${name}/`,
  (path) => exists(`${path}package.json`) |> andDo(of(path)),
  map(mappend("npm install ")),
  chain(pipe(System.exec, mapRej(System.getCommandErrorMessage))),
  map((x) => IO.log(`nodejs modules installed for '${pkgName}'`) |> always(x)),
  chainRej((_) => of(IO.log(`No node modules to install for '${pkgName}'`)))
)(pkgName)


initMadlibModulesFolder :: String -> a -> Wish String a
initMadlibModulesFolder = (path, a) => pipe(
  (p) => System.exec(`mkdir -p ${p}`),
  mapRej(where { System.CommandError(_, msg) => msg }),
  andDo(of(a))
)(path)


projectBaseUrl :: Dependency -> String
projectBaseUrl = (dependency) =>
  `${Constants.TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}`


readMadlibDotJson :: Dependency -> Wish String MadlibDotJson
readMadlibDotJson = (dependency) => MadlibDotJson.load(
  `${projectBaseUrl(dependency)}/madlib.json`
)


readVersionDotLock :: Dependency -> Wish String (Maybe VersionDotLock)
readVersionDotLock = (dependency) => pipe(
  (d) => VersionDotLock.load(
    `${projectBaseUrl(d)}/version.lock`
  ),
  map(Just),
  chainRej((err) => {
    IO.log(err)
    IO.log(`The package downloaded from ${dependency.url} has not been packaged correctly and I do not recommend using it.`)
    return of(Nothing)
  })
)(dependency)


computeBuildHash :: Dependency -> Wish String String
computeBuildHash = (dependency) => pipe(
  (dep) => System.exec(
    `madlib package generate-hash -i ${projectBaseUrl(dep)}`
  ),
  mapRej(System.getCommandErrorMessage)
)(dependency)


prepareValidationInput :: Dependency -> Wish String ValidationInput
prepareValidationInput = (dependency) => pipe(
  readVersionDotLock,
  map((versionDotLock, computedBuildHash, madlibDotJson) => ({
    madlibDotJson,
    versionDotLock,
    computedVersionHash: hashVersion(madlibDotJson.version),
    computedBuildHash
  })),
  ap($, computeBuildHash(dependency)),
  ap($, readMadlibDotJson(dependency))
)(dependency)


printSuccess :: ValidationOutput -> ValidationOutput
printSuccess = (validationOutput) => {
  where(validationOutput) {
    { dependency: { name: Just(n) }} =>
      IO.log(`Package ${n} was successfully installed`)

    _ =>
      IO.log(`Package downloaded from ${validationOutput.dependency.url} was successfully installed`)
  }

  return validationOutput
}


copyPackageFromTmp :: ValidationOutput -> Wish String ValidationOutput
copyPackageFromTmp = (validationOutput) => pipe(
  ifElse(
    .shouldCopy,
    pipe(
      always(copyPackageToMadlibModules(validationOutput.dependency)),
      andDo(of(validationOutput))
    ),
    always(of(validationOutput))
  ),
  mapRej((commandError) => pipe(
    always(validationOutput),
    .dependency,
    .name,
    where {
      Just(n) => `Failed post-processing ${n}\n${System.getCommandErrorMessage(commandError)}`

      Nothing => `Failed post-processing package downloaded from "${validationOutput.dependency.url}"\n${System.getCommandErrorMessage(commandError)}`
    }
  )(commandError))
)(validationOutput)


printWarning :: a -> Warning -> a
printWarning = (a, warning) => where(warning) {
  OutOfRangeVersion =>
    IO.logAndPass(IO.yellow("Package version does not match constraints"), a)

  InvalidVersionHash =>
    IO.logAndPass(IO.yellow("Package version hash is corrupted"), a)

  InvalidBuildHash(pkgName) =>
    IO.logAndPass(
      IO.yellow(`Build hash is corrupted for package '${pkgName}'`),
      a
    )
}


processValidationResult :: ValidationResult ValidationOutput -> ValidationOutput
processValidationResult = where {
  Validated(a) =>
    a

  NotGood(warnings, a) =>
    List.reduce(printWarning, a, warnings)
}


processDependency :: <Context, List Dependency> -> Dependency -> Wish String <Context, List Dependency>
processDependency = (contextAndNextDeps, dependency) => pipe(
  prepareValidationInput,
  chain(
    pipe(
      validate(Tuple.fst(contextAndNextDeps), dependency),
      processValidationResult,
      copyPackageFromTmp
    )
  ),
  map(
    pipe(
      printSuccess,
      (validationResult) => ({
        ...validationResult,
        context: addInstalledPackage(dependency.sanitizedUrl, validationResult.context)
      }),
      (validationResult) => validationResult.shouldCopy
        ? <
            validationResult.context,
            mappend(
              Tuple.snd(contextAndNextDeps),
              fromMaybe([], validationResult.madlibDotJson.dependencies)
            )
          >
        : <validationResult.context, Tuple.snd(contextAndNextDeps)>
    )
  )
)(dependency)


filterAlreadyInstalledDependencies :: Context -> List Dependency -> List Dependency
filterAlreadyInstalledDependencies = (context, dependencies) => List.filter(
  pipe(
    .sanitizedUrl,
    hasPackageBeenInstalled($, context),
    not
  )
)(dependencies)


processDependencies :: Context -> List Dependency -> Wish String <Context, List Dependency>
processDependencies = (context, dependencies) => pipe(
  filterAlreadyInstalledDependencies(context),
  pipe(map(downloadIfNotCached), parallel),
  chain(List.reduceM(processDependency, <context, []>)),
  chain(
    where {
      <_context, []> =>
        of(<_context, []>)

      <_context, nextDependencies> =>
        processDependencies(_context, nextDependencies)
    }
  )
)(dependencies)


installPackages :: Context -> String -> Wish String (List String)
installPackages = (context, madlibDotJsonPath) => pipe(
  readFile,
  mapRej(always(Constants.MADLIB_NOT_FOUND)),
  chain(initMadlibModulesFolder(Constants.MADLIB_MODULES_PATH)),
  chain(getDependencies),
  chain(processDependencies(context)),
  andDo(readDir(Constants.MADLIB_MODULES_PATH)),
  chain(pipe(map(installNodeModules), parallel)),
  map(always([""]))
)(madlibDotJsonPath)


/**
 * prepare runs before everything and takes care of creating a temporary folder
 * as well as reading and saving the content of the package.json file in-memory
 * in order to restore it at it end
 */
prepare :: String -> Wish String String
prepare = (packageDotJsonPath) => pipe(
  always(System.exec(`mkdir -p ${Constants.TEMPORARY_MODULES_PATH}`)),
  andDo(of(packageDotJsonPath)),
  mapRej(System.getCommandErrorMessage),
  chain(exists),
  chain((path) => pipe(
    System.exec,
    mapRej(System.getCommandErrorMessage),
    andDo(of(path))
  )("npm i")),
  chain(readFile)
)(packageDotJsonPath)


IO.log("Installing dependencies ...")

pipe(
  prepare,
  bichain(
    pipe(always("madlib.json"), installPackages(initialContext)),
    (packageDotJsonContent) => pipe(
      installPackages(initialContext),
      chain((x) => writeFile("package.json", TextData(packageDotJsonContent)) |> andDo(of(x)))
    )("madlib.json")
  ),
  fulfill(IO.log, identity)
)("package.json")
