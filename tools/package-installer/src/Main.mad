import type { Wish } from "Wish"
import List from "List"
import { bichain, chainRej, mapRej, parallel, fulfill } from "Wish"
import IO from "IO"
import Http from "Http"
import { readFile, writeFile, exists, readDir } from "FileSystem"
import Json from "Json"
import Either from "Either"
import { Just, Nothing, fromMaybe } from "Maybe"
import System from "System"
import Tuple from "Tuple"
import { always, identity, ifElse, not } from "Function"
import { andDo } from "Monad"
import { TextData } from "Data"

import type { Context } from "./Context"
import type { Dependency } from "./Dependency"
import type { MadlibDotJson } from "./MadlibDotJson"
import type { ValidationResult } from "./Validate"
import { addInstalledPackage, hasPackageBeenInstalled, initialContext } from "./Context"
import { dependencyParser } from "./Dependency"
import { load } from "./MadlibDotJson"
import { validateVersion } from "./Validate"


MADLIB_NOT_FOUND = "The madlib.json file was not found, verify that you have created one or that you run the command from the right directory."
MADLIB_MODULES_PATH = "./madlib_modules/"
TEMPORARY_MODULES_PATH = ".module_cache/"

moveToMadlibModules :: String -> Wish System.CommandError String
moveToMadlibModules = pipe(
  (archivePath) => `mv ${archivePath} ${MADLIB_MODULES_PATH}`,
  System.exec
)

unzipPkg :: String -> Wish System.CommandError String
unzipPkg = pipe(
  (url) => `unzip -d ${TEMPORARY_MODULES_PATH}${url}-tmp ${TEMPORARY_MODULES_PATH}${url}.zip`,
  System.exec
)

renameInnerFolder :: String -> Wish System.CommandError String
renameInnerFolder = pipe(
  (url) => `mv ${TEMPORARY_MODULES_PATH}${url}-tmp/* ${TEMPORARY_MODULES_PATH}${url}-tmp/${url}`,
  System.exec
)

copyPackageToTmpRoot :: String -> Wish System.CommandError String
copyPackageToTmpRoot = pipe(
  (url) => `cp -R ${TEMPORARY_MODULES_PATH}${url}-tmp/${url} ${TEMPORARY_MODULES_PATH}`,
  System.exec
)

copyPackageToMadlibModules :: Dependency -> Wish System.CommandError String
copyPackageToMadlibModules = pipe(
  (dependency) => ({
    destination: `${MADLIB_MODULES_PATH}${fromMaybe("", dependency.name)}`,
    source: `${TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}/`
  }),
  (paths) => `cp -R ${paths.source} ${paths.destination}`,
  System.exec
)

cleanUp :: String -> Wish System.CommandError String
cleanUp = pipe(
  (url) => `rm -r ${TEMPORARY_MODULES_PATH}${url}.zip ${TEMPORARY_MODULES_PATH}${url}-tmp`,
  System.exec
)


getDependencies :: String -> Wish String (List Dependency)
getDependencies = pipe(
  Json.parse(dependencyParser),
  where {
    Either.Left(_) => of([])

    Either.Right(a) => of(a)
  }
)

displayPackagesToInstall :: List <String, String> -> List <String, String>
displayPackagesToInstall = (pkgs) => pipe(
  map(pipe(Tuple.fst, mappend("  - "))),
  mappend(["Packages to install:"]),
  List.unlines,
  (x) => List.len(pkgs) > 0 ? IO.log(x) : x,
  always(pkgs)
)(pkgs)

extractArchive :: String -> Wish String String
extractArchive = (url) => pipe(
  unzipPkg,
  andDo(renameInnerFolder(url)),
  andDo(copyPackageToTmpRoot(url)),
  andDo(cleanUp(url)),
  mapRej(always("Error processing archive"))
)(url)


installNodeModules :: String -> Wish String String
installNodeModules = (pkgName) => pipe(
  (name) => `${MADLIB_MODULES_PATH}${name}/`,
  (path) => exists(`${path}package.json`) |> andDo(of(path)),
  map(mappend("npm install ")),
  chain(pipe(System.exec, mapRej(System.getCommandErrorMessage))),
  map((x) => IO.log(`nodejs modules installed for '${pkgName}'`) |> always(x)),
  chainRej((_) => of(IO.log(`No node modules to install for '${pkgName}'`)))
)(pkgName)

initMadlibModulesFolder :: String -> a -> Wish String a
initMadlibModulesFolder = (path, a) => pipe(
  (p) => System.exec(`mkdir -p ${p}`),
  mapRej(where { System.CommandError(_, msg) => msg }),
  andDo(of(a))
)(path)


downloadIfNotCached :: Dependency -> Wish String Dependency
downloadIfNotCached = (dependency) => pipe(
  (dep) => exists(`${TEMPORARY_MODULES_PATH}${dep.sanitizedUrl}`),
  bichain(always(downloadPackage(dependency)), always(of(dependency)))
)(dependency)

downloadPackage :: Dependency -> Wish String Dependency
downloadPackage = (dependency) => pipe(
  .url,
  Http.get,
  map(where { Http.Response({ data }) => data }),
  mapRej(always(`Package from "${dependency.url}" failed to be downloaded`)),
  chain(writeFile(`${TEMPORARY_MODULES_PATH}${dependency.sanitizedUrl}.zip`)),
  andDo(extractArchive(dependency.sanitizedUrl)),
  andDo(of(dependency))
)(dependency)


readMadlibJSON :: Dependency -> Wish String MadlibDotJson
readMadlibJSON = (dependency) =>
  load(`${TEMPORARY_MODULES_PATH}/${dependency.sanitizedUrl}/madlib.json`)

printSuccess :: ValidationResult -> ValidationResult
printSuccess = (validationResult) => {
  where(validationResult) {
    { dependency: { name: Just(n) }} =>
      IO.log(`Package ${n} was successfully installed`)

    _ =>
      IO.log(`Package downloaded from ${validationResult.dependency.url} was successfully installed`)
  }

  return validationResult
}


processPostValidation :: ValidationResult -> Wish String ValidationResult
processPostValidation = (validationResult) => pipe(
  ifElse(
    .shouldCopy,
    pipe(
      always(copyPackageToMadlibModules(validationResult.dependency)),
      andDo(of(validationResult))
    ),
    always(of(validationResult))
  ),
  mapRej((commandError) => pipe(
    always(validationResult),
    .dependency,
    .name,
    where {
      Just(n) => `Failed post-processing ${n}\n${System.getCommandErrorMessage(commandError)}`

      Nothing => `Failed post-processing package downloaded from "${validationResult.dependency.url}"\n${System.getCommandErrorMessage(commandError)}`
    }
  )(commandError))
)(validationResult)

processDependency :: <Context, List Dependency> -> Dependency -> Wish String <Context, List Dependency>
processDependency = (contextAndNextDeps, dependency) => pipe(
  readMadlibJSON,
  map(validateVersion(Tuple.fst(contextAndNextDeps), dependency)),
  chain(processPostValidation),
  map((validationResult) => where(validationResult) {
    { warning: Just(x) } => IO.log(x) |> always(validationResult)

    _ => validationResult
  }),
  map(pipe(
    printSuccess,
    (validationResult) => ({
      ...validationResult,
      context: addInstalledPackage(dependency.sanitizedUrl, validationResult.context)
    }),
    (validationResult) => validationResult.shouldCopy
      ? <
          validationResult.context,
          mappend(
            Tuple.snd(contextAndNextDeps),
            fromMaybe([], validationResult.madlibDotJson.dependencies)
          )
        >
      : <validationResult.context, Tuple.snd(contextAndNextDeps)>
  ))
)(dependency)

filterAlreadyInstalledDependencies :: Context -> List Dependency -> List Dependency
filterAlreadyInstalledDependencies = (context, dependencies) => List.filter(
  pipe(
    .sanitizedUrl,
    hasPackageBeenInstalled($, context),
    not
  )
)(dependencies)

processDependencies :: Context -> List Dependency -> Wish String <Context, List Dependency>
processDependencies = (context, dependencies) => pipe(
  filterAlreadyInstalledDependencies(context),
  pipe(map(downloadIfNotCached), parallel),
  chain(List.reduceM(processDependency, <context, []>)),
  chain(
    where {
      <_context, []> =>
        of(<_context, []>)

      <_context, nextDependencies> =>
        processDependencies(_context, nextDependencies)
    }
  )
)(dependencies)


installPackages :: Context -> String -> Wish String (List String)
installPackages = (context, madlibDotJsonPath) => pipe(
  readFile,
  mapRej(always(MADLIB_NOT_FOUND)),
  chain(initMadlibModulesFolder(MADLIB_MODULES_PATH)),
  chain(getDependencies),
  chain(processDependencies(context)),
  andDo(readDir(MADLIB_MODULES_PATH)),
  chain(pipe(map(installNodeModules), parallel)),
  map(always([""]))
)(madlibDotJsonPath)


/**
 * prepare runs before everything and takes care of creating a temporary folder
 * as well as reading and saving the content of the package.json file in-memory
 * in order to restore it at it end
 */
prepare :: String -> Wish String String
prepare = (packageDotJsonPath) => pipe(
  always(System.exec(`mkdir -p ${TEMPORARY_MODULES_PATH}`)),
  andDo(of(packageDotJsonPath)),
  mapRej(System.getCommandErrorMessage),
  chain(exists),
  chain((path) => pipe(
    System.exec,
    mapRej(System.getCommandErrorMessage),
    andDo(of(path))
  )("npm i")),
  chain(readFile)
)(packageDotJsonPath)


IO.log("Installing dependencies ...")

pipe(
  prepare,
  bichain(
    pipe(always("madlib.json"), installPackages(initialContext)),
    (packageDotJsonContent) => pipe(
      installPackages(initialContext),
      chain((x) => writeFile("package.json", TextData(packageDotJsonContent)) |> andDo(of(x)))
    )("madlib.json")
  ),
  fulfill(IO.log, identity)
)("package.json")
