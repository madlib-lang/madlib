import type { Maybe } from "Maybe"

import { equals, ifElse, not, always } from "Function"
import { Just, Nothing } from "Maybe"
import { append } from "List"
import IO from "IO"

import type { Context, VersionInfo } from "./Context"
import type { Dependency } from "./Dependency"
import type { MadlibDotJson } from "./MadlibDotJson"
import type { VersionDotLock } from "./VersionDotLock"
import type { VersionRange } from "./Version"

import { findByName, updateEntry } from "./Context"
import { intersectRanges, isInRange } from "./Version"


export alias ValidationInput = {
  madlibDotJson :: MadlibDotJson,
  versionDotLock :: Maybe VersionDotLock,
  computedBuildHash :: String,
  computedVersionHash :: String
}


export alias ValidationOutput = {
  context :: Context,
  shouldCopy :: Boolean,
  dependency :: Dependency,
  madlibDotJson :: MadlibDotJson
}


export type Warning
  = OutOfRangeVersion
  | InvalidVersionHash
  | InvalidBuildHash(String)
  | VersionDotLockMissing
  | BuildHashCouldNotBeGenerated


export type Error
  = CopyToMadlibModulesFailed(ValidationOutput, String)
  | MadlibDotJsonCouldNotBeLoaded(String)


export type Validate a
  = Valid(a)
  | NotValid(List Warning, a)
  | FatalError(Error)


// Proposal 
// export type Validate a
//   = Valid(a)
//   | NotValid(List Warning, a)
//   | FatalError(List Warning, Error, Maybe a)


alias RangeOutput = {
  versionInfo :: VersionInfo,
  shouldCopy :: Boolean
}



instance Functor Validate {
  map = (fn, m) => where(m) {
    Valid(a) =>
      Valid(fn(a))

    NotValid(warnings, a) =>
      NotValid(warnings, fn(a))

    FatalError(e) =>
      FatalError(e)
  }
}


instance Applicative Validate {
  pure = (a) => Valid(a)

  ap = (fn, m) => where(<fn, m>) {
    <Valid(f), Valid(a)> =>
      Valid(f(a))

    <NotValid(warnings, f), Valid(a)> =>
      NotValid(warnings, f(a))

    <Valid(f), NotValid(warnings, a)> =>
      NotValid(warnings, f(a))

    <NotValid(warningsA, f), NotValid(warningsB, a)> =>
      NotValid(mappend(warningsA, warningsB), f(a))

    <FatalError(err), _> =>
      FatalError(err)

    <_, FatalError(err)> =>
      FatalError(err)
  }
}


instance Monad Validate {
  of = pure

  chain = (fn, m) => where(m) {
    Valid(a) =>
      fn(a)

    NotValid(_, a) =>
      pipe(
        fn,
        combine(m)
      )(a)

    FatalError(e) =>
      FatalError(e)
  }
}



printError :: a -> Error -> a
export printError = (a, error) => where(error) {
  CopyToMadlibModulesFailed(_, msg) =>
    IO.logAndPass(`  - ${IO.red(msg)}`, a)
}


printWarning :: a -> Warning -> a
export printWarning = (a, warning) => where(warning) {
  OutOfRangeVersion =>
    IO.logAndPass(`  - ${IO.yellow("Package version does not match constraints")}`, a)

  InvalidVersionHash =>
    IO.logAndPass(`  - ${IO.yellow("Package version hash is corrupted")}`, a)

  InvalidBuildHash(pkgName) =>
    IO.logAndPass(
      `  - ${IO.yellow("Build hash is corrupted for package '" ++ pkgName ++ "'")}`,
      a
    )

  VersionDotLockMissing =>
    IO.logAndPass(`  - ${IO.yellow("version.lock file missing")}`, a)
}


mapFatalError :: (Error -> Error) -> Validate a -> Validate a
export mapFatalError = (f, v) => where(v) {
  FatalError(e) =>
    FatalError(f(e))

  _ =>
    v
}


combine :: Validate a -> Validate b -> Validate b
combine = (a, b) => where(<a, b>) {
  <Valid(_), _> =>
    b

  <NotValid(warnings, _), Valid(x)> =>
    NotValid(warnings, x)

  <NotValid(warningsA, _), NotValid(warningsB, x)> =>
    NotValid(mappend(warningsA, warningsB), x)
}


addWarning :: Warning -> Validate a -> Validate a
export addWarning = (warning, validationResult) => where(validationResult) {
  Valid(a) =>
    NotValid([warning], a)

  NotValid(warnings, a) =>
    NotValid(append(warning, warnings), a)
}


fail :: Error -> Validate a -> Validate a
export fail = (error, _) => FatalError(error)


hasFailed :: Validate a -> Boolean
export hasFailed = where {
  FatalError(_) =>
    true

  _ =>
    false
}


setValidationResultValue :: b -> Validate a -> Validate b
setValidationResultValue = (value) => where {
  Valid(_) =>
    Valid(value)

  NotValid(warnings, _) =>
    NotValid(warnings, value)
}

unsafeGetValidationValue :: Validate a -> a
export unsafeGetValidationValue = where {
  Valid(a) => a
  NotValid(_, a) => a
}


buildGoodRangeResult :: MadlibDotJson -> VersionInfo -> VersionRange -> Validate RangeOutput
buildGoodRangeResult = (madlibDotJson, versionInfo, versionRange) => Valid({
  versionInfo: { version: Just(madlibDotJson.version), range: versionRange },
  shouldCopy: Just(madlibDotJson.version) != versionInfo.version
})


buildBadRangeResult :: MadlibDotJson -> VersionInfo -> VersionRange -> Validate RangeOutput
buildBadRangeResult = (madlibDotJson, versionInfo, versionRange) => NotValid(
  [OutOfRangeVersion],
  {
    versionInfo: {
      version: versionInfo.version == Nothing
        ? Just(madlibDotJson.version)
        : versionInfo.version,
      range: versionRange
    },
    shouldCopy: versionInfo.version == Nothing,
  }
)


buildValidationOutput :: Context -> MadlibDotJson -> Dependency -> Validate RangeOutput -> Validate ValidationOutput
buildValidationOutput = (context, madlibDotJson, dependency, rangeResult) => {
  rangeOutput = unsafeGetValidationValue(rangeResult)

  validationOutput = {
    context: updateEntry(
      madlibDotJson.name,
      rangeOutput.versionInfo,
      context
    ),
    shouldCopy: rangeOutput.shouldCopy,
    dependency: { ...dependency, name: Just(madlibDotJson.name) },
    madlibDotJson
  }

  return where(rangeResult) {
    Valid(_) => Valid(validationOutput)
    NotValid(warnings, _) => NotValid(warnings, validationOutput)
  }
}


validateVersion :: Context -> Dependency -> ValidationInput -> Validate ValidationOutput
validateVersion = (context, dependency, validationInput) => {
  madlibDotJson = validationInput.madlibDotJson
  versionInfo = findByName(madlibDotJson.name, context)

  return pipe(
    intersectRanges(dependency.versionRange),
    ifElse(
      isInRange(madlibDotJson.version),
      buildGoodRangeResult(madlibDotJson, versionInfo),
      buildBadRangeResult(madlibDotJson, versionInfo)
    ),
    buildValidationOutput(context, madlibDotJson, dependency)
  )(versionInfo.range)
}


validateHashes :: ValidationInput -> Validate ValidationInput
validateHashes = (validationInput) => {
  validatedBuildHash = where(validationInput.versionDotLock) {
    Just(versionDotLock) =>
      ifElse(
        pipe(equals(validationInput.computedBuildHash), not),
        always(NotValid([InvalidBuildHash(validationInput.madlibDotJson.name)], ())),
        always(Valid(())),
        versionDotLock.buildHash
      )

    Nothing =>
      NotValid([], ())
  }

  validatedVersionHash = where(validationInput.versionDotLock) {
    Just(versionDotLock) =>
      ifElse(
        pipe(equals(validationInput.computedVersionHash), not),
        always(NotValid([InvalidVersionHash], ())),
        always(Valid(())),
        versionDotLock.versionHash
      )

    Nothing =>
      Valid(())
  }

  return setValidationResultValue(
    validationInput,
    combine(validatedBuildHash, validatedVersionHash)
  )
}


validate :: Context -> Dependency -> Validate ValidationInput -> Validate ValidationOutput
export validate = (context, dependency, validationInput) => pipe(
  chain(validateHashes),
  chain(validateVersion(context, dependency))
)(validationInput)
