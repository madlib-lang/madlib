import type { Maybe } from "Maybe"
import { equals, ifElse, not, always } from "Function"
import { Just, Nothing } from "Maybe"
import { append, isEmpty } from "List"

import type { Context, VersionInfo } from "./Context"
import type { Dependency } from "./Dependency"
import type { MadlibDotJson } from "./MadlibDotJson"
import type { VersionDotLock } from "./VersionDotLock"
import type { VersionRange } from "./Version"
import type { Warning } from "./Warning"
import type { Error } from "./Error"

import { findByName, updateEntry } from "./Context"
import { intersectRanges, isInRange } from "./Version"
import {
  InvalidBuildHash,
  OutOfRangeVersion,
  VersionDotLockMissing,
  InvalidVersionHash
} from "./Warning"


export alias ValidationInput = {
  madlibDotJson :: MadlibDotJson,
  versionDotLock :: Maybe VersionDotLock,
  computedBuildHash :: String,
  computedVersionHash :: String
}


export alias ValidationOutput = {
  context :: Context,
  shouldCopy :: Boolean,
  dependency :: Dependency,
  madlibDotJson :: MadlibDotJson
}


export type Validate a
  = Valid(a)
  | NotValid(List Warning, List Error, a)
  | FatalError(Error)


alias RangeOutput = {
  versionInfo :: VersionInfo,
  shouldCopy :: Boolean
}


instance Functor Validate {
  map = (fn, m) => where(m) {
    Valid(a) =>
      Valid(fn(a))

    NotValid(warnings, errors, a) =>
      NotValid(warnings, errors, fn(a))

    FatalError(e) =>
      FatalError(e)
  }
}

instance Applicative Validate {
  pure = (a) => Valid(a)

  ap = (fn, m) => where(<fn, m>) {
    <Valid(f), Valid(a)> =>
      Valid(f(a))

    <NotValid(warnings, errors, f), Valid(a)> =>
      NotValid(warnings, errors, f(a))

    <Valid(f), NotValid(warnings, errors, a)> =>
      NotValid(warnings, errors, f(a))

    <NotValid(warningsA, errorsA, f), NotValid(warningsB, errorsB, a)> =>
      NotValid(mappend(warningsA, warningsB), mappend(errorsA, errorsB), f(a))

    <FatalError(err), _> =>
      FatalError(err)

    <_, FatalError(err)> =>
      FatalError(err)
  }
}

instance Monad Validate {
  of = pure

  chain = (fn, m) => where(m) {
    Valid(a) =>
      fn(a)

    NotValid(_, _, a) =>
      pipe(
        fn,
        combine(m)
      )(a)

    FatalError(e) =>
      FatalError(e)
  }
}


combine :: Validate a -> Validate b -> Validate b
combine = (a, b) => where(<a, b>) {
  <Valid(_), _> =>
    b

  <NotValid(warnings, errors, _), Valid(x)> =>
    NotValid(warnings, errors, x)

  <NotValid(warningsA, errorsA, _), NotValid(warningsB, errorsB, x)> =>
    NotValid(mappend(warningsA, warningsB), mappend(errorsA, errorsB), x)
}


addWarning :: Warning -> Validate a -> Validate a
export addWarning = (warning, validationResult) => where(validationResult) {
  Valid(a) =>
    NotValid([warning], [], a)

  NotValid(warnings, errors, a) =>
    NotValid(append(warning, warnings), errors, a)
}


addError :: Error -> Validate a -> Validate a
export addError = (error, validationResult) => where(validationResult) {
  Valid(a) =>
    NotValid([], [error], a)

  NotValid(warnings, errors, a) =>
    NotValid(warnings, append(error, errors), a)
}


hasErrors :: Validate a -> Boolean
export hasErrors = where {
  NotValid(_, errors, _) =>
    !isEmpty(errors)

  _ =>
    false
}


setValidationResultValue :: b -> Validate a -> Validate b
setValidationResultValue = (value) => where {
  Valid(_) =>
    Valid(value)

  NotValid(warnings, errors, _) =>
    NotValid(warnings, errors, value)
}


getValidationValue :: Validate a -> a
export getValidationValue = where {
  Valid(a) => a
  NotValid(_, _, a) => a
}


buildGoodRangeResult :: MadlibDotJson -> VersionInfo -> VersionRange -> Validate RangeOutput
buildGoodRangeResult = (madlibDotJson, versionInfo, versionRange) => Valid({
  versionInfo: { version: Just(madlibDotJson.version), range: versionRange },
  shouldCopy: Just(madlibDotJson.version) != versionInfo.version
})


buildBadRangeResult :: MadlibDotJson -> VersionInfo -> VersionRange -> Validate RangeOutput
buildBadRangeResult = (madlibDotJson, versionInfo, versionRange) => NotValid(
  [OutOfRangeVersion],
  [],
  {
    versionInfo: {
      version: versionInfo.version == Nothing
        ? Just(madlibDotJson.version)
        : versionInfo.version,
      range: versionRange
    },
    shouldCopy: versionInfo.version == Nothing,
  }
)


buildValidationOutput :: Context -> MadlibDotJson -> Dependency -> Validate RangeOutput -> Validate ValidationOutput
buildValidationOutput = (context, madlibDotJson, dependency, rangeResult) => {
  rangeOutput = getValidationValue(rangeResult)

  validationOutput = {
    context: updateEntry(
      madlibDotJson.name,
      rangeOutput.versionInfo,
      context
    ),
    shouldCopy: rangeOutput.shouldCopy,
    dependency: { ...dependency, name: Just(madlibDotJson.name) },
    madlibDotJson
  }

  return where(rangeResult) {
    Valid(_) => Valid(validationOutput)
    NotValid(warnings, errors, _) => NotValid(warnings, errors, validationOutput)
  }
}


validateVersion :: Context -> Dependency -> ValidationInput -> Validate ValidationOutput
validateVersion = (context, dependency, validationInput) => {
  madlibDotJson = validationInput.madlibDotJson
  versionInfo = findByName(madlibDotJson.name, context)

  return pipe(
    intersectRanges(dependency.versionRange),
    ifElse(
      isInRange(madlibDotJson.version),
      buildGoodRangeResult(madlibDotJson, versionInfo),
      buildBadRangeResult(madlibDotJson, versionInfo)
    ),
    buildValidationOutput(context, madlibDotJson, dependency)
  )(versionInfo.range)
}


validateHashes :: ValidationInput -> Validate ValidationInput
validateHashes = (validationInput) => {
  validatedBuildHash = where(validationInput.versionDotLock) {
    Just(versionDotLock) =>
      ifElse(
        pipe(equals(validationInput.computedBuildHash), not),
        always(NotValid([InvalidBuildHash(validationInput.madlibDotJson.name)], [], ())),
        always(Valid(())),
        versionDotLock.buildHash
      )

    Nothing =>
      NotValid([VersionDotLockMissing], [], ())
  }

  validatedVersionHash = where(validationInput.versionDotLock) {
    Just(versionDotLock) =>
      ifElse(
        pipe(equals(validationInput.computedVersionHash), not),
        always(NotValid([InvalidVersionHash], [], ())),
        always(Valid(())),
        versionDotLock.versionHash
      )

    Nothing =>
      Valid(())
  }

  return setValidationResultValue(
    validationInput,
    combine(validatedBuildHash, validatedVersionHash)
  )
}

validate :: Context -> Dependency -> Validate ValidationInput -> Validate ValidationOutput
export validate = (context, dependency, validationInput) => pipe(
  chain(validateHashes),
  chain(validateVersion(context, dependency))
)(validationInput)
