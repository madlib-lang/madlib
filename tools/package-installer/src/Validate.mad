import type { Maybe } from "Maybe"
import { equals, ifElse, not, always } from "Function"
import { Just, Nothing } from "Maybe"
import { append, isEmpty } from "List"

import type { Context, VersionInfo } from "./Context"
import type { Dependency } from "./Dependency"
import type { MadlibDotJson } from "./MadlibDotJson"
import type { VersionDotLock } from "./VersionDotLock"
import type { VersionRange } from "./Version"
import { findByName, updateEntry } from "./Context"
import { intersectRanges, isInRange } from "./Version"


export alias ValidationInput = {
  madlibDotJson :: MadlibDotJson,
  versionDotLock :: Maybe VersionDotLock,
  computedBuildHash :: String,
  computedVersionHash :: String
}

export alias ValidationOutput = {
  context :: Context,
  shouldCopy :: Boolean,
  dependency :: Dependency,
  madlibDotJson :: MadlibDotJson
}

export type Warning
  = OutOfRangeVersion
  | InvalidVersionHash
  | InvalidBuildHash(String)
  | VersionDotLockMissing


export type Error
  = CopyToMadlibModulesFailed(String)


export type Validate a
  = Valid(a)
  | NotValid(List Warning, List Error, a)


alias RangeOutput = {
  versionInfo :: VersionInfo,
  shouldCopy :: Boolean
}


combineResults :: Validate a -> Validate b -> Validate b
combineResults = (a, b) => where(<a, b>) {
  <Valid(_), _> =>
    b

  <NotValid(warnings, errors, _), Valid(x)> =>
    NotValid(warnings, errors, x)

  <NotValid(warningsA, errorsA, _), NotValid(warningsB, errorsB, x)> =>
    NotValid(mappend(warningsA, warningsB), mappend(errorsA, errorsB), x)
}


addWarning :: Warning -> Validate a -> Validate a
export addWarning = (warning, validationResult) => where(validationResult) {
  Valid(a) =>
    NotValid([warning], [], a)

  NotValid(warnings, errors, a) =>
    NotValid(append(warning, warnings), errors, a)
}


addError :: Error -> Validate a -> Validate a
export addError = (error, validationResult) => where(validationResult) {
  Valid(a) =>
    NotValid([], [error], a)

  NotValid(warnings, errors, a) =>
    NotValid(warnings, append(error, errors), a)
}


hasErrors :: Validate a -> Boolean
export hasErrors = where {
  NotValid(_, errors, _) =>
    !isEmpty(errors)

  _ =>
    false
}


setValidationResultValue :: b -> Validate a -> Validate b
setValidationResultValue = (value) => where {
  Valid(_) =>
    Valid(value)

  NotValid(warnings, errors, _) =>
    NotValid(warnings, errors, value)
}


getValidationValue :: Validate a -> a
export getValidationValue = where {
  Valid(a) => a
  NotValid(_, _, a) => a
}


buildGoodRangeResult :: MadlibDotJson -> VersionInfo -> VersionRange -> Validate RangeOutput
buildGoodRangeResult = (madlibDotJson, versionInfo, versionRange) => Valid({
  versionInfo: { version: Just(madlibDotJson.version), range: versionRange },
  shouldCopy: Just(madlibDotJson.version) != versionInfo.version
})


buildBadRangeResult :: MadlibDotJson -> VersionInfo -> VersionRange -> Validate RangeOutput
buildBadRangeResult = (madlibDotJson, versionInfo, versionRange) => NotValid(
  [OutOfRangeVersion],
  [],
  {
    versionInfo: {
      version: versionInfo.version == Nothing
        ? Just(madlibDotJson.version)
        : versionInfo.version,
      range: versionRange
    },
    shouldCopy: versionInfo.version == Nothing,
  }
)


buildValidationOutput :: Context -> MadlibDotJson -> Dependency -> Validate RangeOutput -> Validate ValidationOutput
buildValidationOutput = (context, madlibDotJson, dependency, rangeResult) => {
  rangeOutput = getValidationValue(rangeResult)

  validationOutput = {
    context: updateEntry(
      madlibDotJson.name,
      rangeOutput.versionInfo,
      context
    ),
    shouldCopy: rangeOutput.shouldCopy,
    dependency: { ...dependency, name: Just(madlibDotJson.name) },
    madlibDotJson
  }

  return where(rangeResult) {
    Valid(_) => Valid(validationOutput)
    NotValid(warnings, errors, _) => NotValid(warnings, errors, validationOutput)
  }
}


validateVersion :: Context -> Dependency -> ValidationInput -> Validate ValidationOutput
validateVersion = (context, dependency, validationInput) => {
  madlibDotJson = validationInput.madlibDotJson
  versionInfo = findByName(madlibDotJson.name, context)

  return pipe(
    intersectRanges(dependency.versionRange),
    ifElse(
      isInRange(madlibDotJson.version),
      buildGoodRangeResult(madlibDotJson, versionInfo),
      buildBadRangeResult(madlibDotJson, versionInfo)
    ),
    buildValidationOutput(context, madlibDotJson, dependency)
  )(versionInfo.range)
}


validateHashes :: ValidationInput -> Validate ValidationInput
validateHashes = (validationInput) => {
  validatedBuildHash = where(validationInput.versionDotLock) {
    Just(versionDotLock) =>
      ifElse(
        pipe(equals(validationInput.computedBuildHash), not),
        always(NotValid([InvalidBuildHash(validationInput.madlibDotJson.name)], [], ())),
        always(Valid(())),
        versionDotLock.buildHash
      )

    Nothing =>
      NotValid([VersionDotLockMissing], [], ())
  }

  validatedVersionHash = where(validationInput.versionDotLock) {
    Just(versionDotLock) =>
      ifElse(
        pipe(equals(validationInput.computedVersionHash), not),
        always(NotValid([InvalidVersionHash], [], ())),
        always(Valid(())),
        versionDotLock.versionHash
      )

    Nothing =>
      Valid(())
  }

  return setValidationResultValue(
    validationInput,
    combineResults(validatedBuildHash, validatedVersionHash)
  )
}

validate :: Context -> Dependency -> Maybe ValidationInput -> Validate ValidationOutput
export validate = (context, dependency, validationInput) => where(validationInput) {
  Just(vi) =>
    _validate(context, dependency, vi)
  
  // Nothing =>
    
}

_validate :: Context -> Dependency -> ValidationInput -> Validate ValidationOutput
_validate = (context, dependency, validationInput) => {
  validatedHashes = validateHashes(validationInput)
  validatedVersion = validateVersion(context, dependency, validationInput)

  return combineResults(validatedHashes, validatedVersion)
}
