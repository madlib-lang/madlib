import IO from "IO"
import Dictionary from "Dictionary"
import Thread from "Thread"
import Wish from "Wish"

prompt :: {} -> String
prompt = extern "madlib__debugger__prompt"

// pause :: {} -> {}
// pause = extern "pause"

pauseOtherThreads :: {} -> {}
pauseOtherThreads = extern "madlib__process__pauseOtherThreads"

releaseThreads :: {} -> {}
releaseThreads = extern "madlib__process__releaseThreads"

alias Frame = {
  functionCode :: String,
  functionName :: String,
  localValues :: Dictionary String ({} -> String),
}

alias FrameStore = {
  updateCurrentFrame :: (Frame -> Frame) -> {},
  addFrame :: String -> Dictionary String ({} -> String) -> {},
  dropFrame :: {} -> {},
  getFrames :: {} -> List Frame,
}

makeFrameStore :: {} -> FrameStore
makeFrameStore = () => {
  frames = []

  updateCurrentFrame :: (Frame -> Frame) -> {}
  updateCurrentFrame = (f) => {
    where (frames) {
      [frame, ...more] => do {
        frames = [f(frame), ...more]
      }

      _ =>
        {}
    }
  }

  addFrame :: String -> Dictionary String ({} -> String) -> {}
  addFrame = (functionName, args) => {
    frames = [{ functionCode: "", functionName, localValues: args }, ...frames]
  }

  dropFrame :: {} -> {}
  dropFrame = () => {
    where(frames) {
      [_, ...rest] => do {
        frames = rest
      }

      _ =>
        {}
    }
  }

  getFrames :: {} -> List Frame
  getFrames = () => frames

  return {
    addFrame,
    dropFrame,
    getFrames,
    updateCurrentFrame,
  }
}

FrameStore = makeFrameStore()

BREAKPOINT_MUTEX = Thread.createMutex()

breakPoint = () => {
  Thread.mutexLock(BREAKPOINT_MUTEX)
  pauseOtherThreads()
  run = () => {
    IO.put("Breakpoint reached - command: ")
    where(prompt()) {
      _ => do {
        releaseThreads()
        IO.putLine("RELEASED FROM breakPoint")
      }

    //   "continue" => do {
    //     releaseThreads()
    //   }
  
    //   _ => do {
    //     IO.putLine("PRINT INFO")
    //     where(FrameStore.getFrames()) {
    //       [{ functionName, localValues }, ..._] => do {
    //         IO.putLine(`Currently in function '${functionName}'`)
    //         IO.putLine(`Vars in scope:`)
    //         IO.log(map((eval) => eval(), localValues))
    //       }
  
    //       _ =>
    //         {}
    //     }
    //     run()
    //   }
    }
  }

  run()
  Thread.mutexUnlock(BREAKPOINT_MUTEX)
}


// ------- Application Code --------

/**
 * All functions get a prelude to register the current frame
 * All local bindings extend the current frame
 * Before exiting a function we need to drop the current frame
 *
 * *the above wiring is injected by the compiler.
 */


add = (a, b) => {
  FrameStore.addFrame("add", {{ "a": () => inspect(a), "b": () => inspect(b) }})
  breakPoint()
  __res = a + b
  FrameStore.dropFrame()
  return __res
}


everySec = (v) => {
  IO.log(v)
//   IO.log(v)
  if (v == "2") do {
    breakPoint()
  }
  everySec(v ++ "2")
}


main = (args) => {
  FrameStore.addFrame("main", {{ "args": () => inspect(args) }})

  t1 = Thread.create((_, _) => {
    everySec("1")
    // Wish.fulfill(() => {}, () => {}, everySec("1"))
  })
  t2 = Thread.create((_, _) => {
    everySec("2")
    // Wish.fulfill(() => {}, () => {}, everySec("2"))
  })

  Wish.fulfill(() => {}, () => {}, t1)
  Wish.fulfill(() => {}, () => {}, t2)

  IO.log("before")

  IO.log(add(1, 2))
//   breakPoint()

  __res = IO.log("after")
  FrameStore.dropFrame()
  return __res
}
