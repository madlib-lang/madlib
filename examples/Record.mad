import L from "List"
import json from "./r.json"


type T a b = X a b

wrong :: { l :: Boolean } -> String
wrong = (a) => a.name

wrong2 = (rec) => rec.x + rec.y

wrong3 = where
  is { x }: x
  is { y }: y

wrong4 = (a) => where
  is { x }: x
  is { y }: y

wrong4(true, { x: 3 })

/*
That is actually a valid call, because the function defines a record with a property l of type Boolean.
What is wrong though is the function definition. wrong type annotation says it takes a { l :: Boolean }
but in practice it is a { name :: String }.
*/
wrong({ l: true })


wrong2({ x: 3, y: 4 })
wrong2({ x: 3, z: 4 })

/*
The wrong3 call is because on the input record, there's a pattern that checks for a y key. So the given
record is not fulfilling the requirement of wrong3 which then expects { x :: a, y :: a }
*/
wrong3({ x: 3 })




.x({ x: 3 })

rec = { x: 3 }
rec.x


[{ x: 1 }, { x: 7 }]

/*
This should fail because the two records given do not match!
*/
[{ a: 1 }, { x: 7 }]

/*
This should fail because the two records given do not match!
What happens if you loop over it say:
map(.b, x)
*/
a = [{ x: 1, b: 1 }, { x: 7 }]

p = pipe(
  .x,
  .y
)({ x: { y: 5 }})

/*
This should not work because 'y' is missing from the initial value!!
*/
sum = pipe(
  of,
  ap([.x, .y]),
  where is [x, y]: x + y
)({ x: 5, y: 5 })

fn :: Number -> Number
fn = pipe(
  (x) => x + 1,
  (x) => x * 2
)

a = fn(5)



[1, 2, 3, "4"]


if ("ok") {
  true
} else {
  false
}


interface D a {
  d :: a -> a
}

instance D Number {
  d = (k) => k + 1
}
