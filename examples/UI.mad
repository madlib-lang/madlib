import { Wish, fulfill } from "Wish"
import {} from "Number"

#-
import { init } from "snabbdom/init"
import { h } from 'snabbdom/h'
import { attributesModule } from 'snabbdom/modules/attributes'
import { eventListenersModule } from 'snabbdom/modules/eventlisteners'

const AppEnv = {
  patch: null,
  currentElement: null,
  currentState: null,
  rootComponent: null,
}
-#

type Element = Element

export alias Component a = a -> Element

type Event = Event


type Attribute
  = AttributeId String
  | AttributeClass String
  | OnClick (a -> Event -> List (Wish (a -> a) (a -> a)))
  | OnMouseOver (a -> Event -> List (Wish (a -> a) (a -> a)))
  | OnMouseOut (a -> Event -> List (Wish (a -> a) (a -> a)))


#-
const getAttributeTuple = attr => {
  switch(attr.__constructor) {
    case 'AttributeId':
      return ["id", attr.__args[0]]
    case 'AttributeClass':
      return ["class", attr.__args[0]]
    case 'OnClick':
      return ["onClick", attr.__args[0]]
    case 'OnMouseOver':
      return ["onMouseOver", attr.__args[0]]
    case 'OnMouseOut':
      return ["onMouseOut", attr.__args[0]]
  }
}

const getCurrentState = () => AppEnv.currentState

const handleReceived = updater => {
  AppEnv.currentState = updater(getCurrentState())
  const newElement = AppEnv.rootComponent(AppEnv.currentState)
  AppEnv.patch(AppEnv.currentElement, newElement)
  AppEnv.currentElement = newElement
}

const wrapEventHandler = handler => {
  return event => {
    // So now calling an event handler gives us a list of wishes
    const wishes = handler(AppEnv.currentState)(event)
    wishes.forEach(fulfill(handleReceived)(handleReceived))
  }
}

const objectifyAttrs = attrs => attrs.reduce((obj, attr) => {
  const [attrName, attrValue] = getAttributeTuple(attr)
  let resolvedAttr

  if (attrName === "id" || attrName === "class") {
    resolvedAttr = { ...obj, attrs: { ...obj.attrs, [attrName]: attrValue }}
  } else if (attrName === "onClick") {
    resolvedAttr = { ...obj, on: { ...obj.on, click: wrapEventHandler(attrValue) }}
  } else if (attrName === "onMouseOver") {
    resolvedAttr = { ...obj, on: { ...obj.on, mouseover: wrapEventHandler(attrValue) }}
  } else if (attrName === "onMouseOut") {
    resolvedAttr = { ...obj, on: { ...obj.on, mouseout: wrapEventHandler(attrValue) }}
  }

  return resolvedAttr
}, {})
-#




id :: String -> Attribute
export id = AttributeId

className :: String -> Attribute
export className = AttributeClass

onClick :: (a -> Event -> List (Wish (a -> a) (a -> a))) -> Attribute
export onClick = OnClick

onMouseOver :: (a -> Event -> List (Wish (a -> a) (a -> a))) -> Attribute
export onMouseOver = OnMouseOver

onMouseOut :: (a -> Event -> List (Wish (a -> a) (a -> a))) -> Attribute
export onMouseOut = OnMouseOut

text :: String -> Element
export text = (content) => #- content -#

div :: List Attribute -> List Element -> Element
export div = (attrs, children) => #- h("div", objectifyAttrs(attrs), children) -#

span :: List Attribute -> List Element -> Element
export span = (attrs, children) => #- h("span", objectifyAttrs(attrs), children) -#

p :: List Attribute -> List Element -> Element
export p = (attrs, children) => #- h("p", objectifyAttrs(attrs), children) -#

input :: List Attribute -> List Element -> Element
export input = (attrs, children) => #- h("input", objectifyAttrs(attrs), children) -#

button :: List Attribute -> List Element -> Element
export button = (attrs, children) => #- h("button", objectifyAttrs(attrs), children) -#

/**
 * render - boostraps the app and takes a component, and an initial state as parameters
 */
render :: Component a -> a -> String -> ()
export render = (component, initialState, containerId) => {
  initialElement = component(initialState)
  #-
  const patch = init([attributesModule, eventListenersModule])
  patch(document.getElementById(containerId), initialElement)

  AppEnv.patch = patch
  AppEnv.currentElement = initialElement
  AppEnv.rootComponent = component
  AppEnv.currentState = initialState
  -#

  return ()
}


alias State = Number

initialState :: State
initialState = 0


MyApp :: Component State
MyApp = (count) =>
  <div id="id" className="class">
    <div>{`Current count is ${show(count)}`}</div>
    <div>
      <button onClick={(state, event) => [of((s) => s + 1)]}>
        {"increment"}
      </button>
    </div>
  </div>

<div>{"Some text!"}</div>

<div><div><span></span></div><div><span></span></div></div>
