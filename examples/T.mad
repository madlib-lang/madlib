interface Semigroup a {
  assoc :: a -> a -> a
}

interface Semigroup w => Monoid w {
  mempty :: w
  mappend :: w -> w -> w
}

instance Semigroup (List a) {
  assoc = (xs1, xs2) => (#- xs1.concat(xs2) -#)
}

instance Monoid (List a) {
  mempty = []
  mappend = (xs1, xs2) => (#- xs1.concat(xs2) -#)
}

interface Functor m {
  map :: (a -> b) -> m a -> m b
}

interface Functor m => Applicative m {
  ap :: m (a -> b) -> m a -> m b
  pure :: a -> m a
}

interface Applicative m => Monad m {
  of :: a -> m a
  chain :: (a -> m b) -> m a -> m b
}

interface Monad m => MonadTrans m t {
  lift :: m a -> t m a
}


andDo :: Monad m => m b -> m a -> m b
export andDo = (b, a) => chain((_) => b, a)


export type WriterT w m a = WriterT (m <a, w>)


runWriterT :: WriterT w m a -> m <a, w>
export runWriterT = where is WriterT m: m

liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2 = (f, x1, x2) => ap(map(f, x1), x2)

instance Functor m => Functor (WriterT w m) {
  map = (f, m) => WriterT(map(where is <a, w>: <f(a), w>, runWriterT(m)))
}

instance (Applicative m, Monoid w) => Applicative (WriterT w m) {
  pure = (x) => WriterT(pure(<x, mempty>))

  ap = (mf, mm) => WriterT(liftA2((x1, x2) => where(x1)
    is <a, w>: where(x2) is <b, ww>: <a(b), mappend(w, ww)>
    , runWriterT(mf), runWriterT(mm)))
}

instance (Monoid w, Monad m) => Monad (WriterT w m) {
  of = pure

  chain = (f, m) => WriterT(
    chain(
      where is <a, w>: chain(
        where is <b, ww>: of(<b, mappend(w, ww)>)
        , runWriterT(f(a)))
      , runWriterT(m))
  )
}

instance (Monad m, Monoid w) => MonadTrans m (WriterT w) {
  lift = (m) => WriterT(chain((a) => of(<a, mempty>), m))
}

export type Identity a = Identity a

run :: Identity a -> a
export runIdentity = where
  is Identity a: a

instance Functor Identity {
  map = (f, m) => Identity(f(runIdentity(m)))
}

instance Applicative Identity {
  pure = Identity

  ap = (mf, mm) => Identity(runIdentity(mf)(runIdentity(mm)))
}

instance Monad Identity {
  of = pure

  chain = (f, mm) => f(runIdentity(mm))
}


export type StateT s m a = StateT (s -> m <a, s>)

runStateT :: StateT s m a -> s -> m <a, s>
export runStateT = (m) => where(m) is StateT f: (a) => f(a)

instance Functor m => Functor (StateT s m) {
  map = (f, m) => StateT((s) =>
    map(
      where is <a, ss>: <f(a), ss>,
      runStateT(m, s)
    )
  )
}

instance Monad m => Applicative (StateT s m) {
  pure = (a) => StateT((s) => of(<a, s>))

  ap = (mf, mm) => StateT(
    (s) => chain(
      where is <f, ss>: chain(
        where is <m, sss>: of(<f(m), sss>),
        runStateT(mm)(ss)
      ),
      runStateT(mf)(s)
    )
  )
}

instance Monad m => Monad (StateT s m) {
  of = (a) => StateT((s) => of(<a, s>))

  chain = (f, m) => StateT(
    (s) => chain(
      where is <a, ss>: runStateT(f(a), ss),
      runStateT(m, s)
    )
  )
}

instance Monad m => MonadTrans m (StateT s) {
  lift = (m) => StateT((s) => chain((a) => of(<a, s>), m))
}

interface (Monoid w, Monad m) => MonadWriter w m {
  tell :: w -> m ()
}

instance (Monoid w, Monad m) => MonadWriter w (WriterT w m) {
  tell = (v) => WriterT(of(<(), v>))
}

instance (Monoid w, Monad m, MonadWriter w m) => MonadWriter w (StateT s m) {
  tell = pipe(tell, lift)
}

interface Monad m => MonadState s m {
  put :: s -> m ()
  get :: m s
  modify :: (s -> s) -> m ()
}

instance Monad m => MonadState s (StateT s m) {
  put = (s) => StateT((_) => of(<(), s>))

  get = StateT((s) => of(<s, s>))

  modify = (f) => StateT((s) => of(<(), f(s)>))
}

instance (Monoid w, Monad m, MonadState s m) => MonadState s (WriterT w m) {
  put = pipe(put, lift)
  
  get = lift(get)
  
  modify = pipe(modify, lift)
}

alias Stack a = StateT Number (WriterT (List String) Identity) a

hep :: MonadWriter w m => w -> m ()
hep = tell

sumAndLog :: MonadWriter (List String) m => Number -> m Number
sumAndLog = pipe(
  of,
  chain((x) => of(x + 18)),
  chain((x) => tell(['Summed 18']) |> andDo(of(x)))
)

runStack :: Number -> Stack a -> <<a, Number>, List String>
runStack = (x) => pipe(
  (m) => runStateT(m, x),
  runWriterT,
  runIdentity
)

of(3)
  |> chain((x) => of(29 * x))
  |> map((x) => x * 17)
  |> chain((_) => hep(['HOP']))
  |> chain((_) => hep(['HIP']))
  |> chain((_) => put(157))
  |> chain((_) => hep(['HAP']))
  |> andDo(of(5))
  |> chain(sumAndLog)
  |> runStack(37)
