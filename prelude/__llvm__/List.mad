import type { Maybe } from "./Maybe"

import {} from "./Functor"
import {} from "./Monoid"
import {} from "./PrettyShow"
import { Just, Nothing } from "./Maybe"
import { complement } from "./Function"
import { log, prettyLog } from "./IO"

push :: a -> List a -> List a
push = extern "MadList_push"
export push

map_ :: (a -> b) -> List a -> List b
map_ = extern "MadList_map"

len :: List a -> Integer
len = extern "MadList_length"
export len


showWith :: (a -> String) -> List a -> String
showWith = (with, list) => {
  processItems = (processed, items) => where(items) {
    [first, second, ...rest] => do {
      return processItems(processed ++ with(first) ++ ", ", push(second, rest))
    }

    [last] => do {
      return processed ++ with(last)
    }

    [] =>
      ""
  }

  return "[" ++ processItems("", list) ++ "]"
}


instance Show a => Show (List a) {
  show = showWith(show)
}

instance PrettyShow a => PrettyShow (List a) {
  ppShow = showWith(ppShow)
}


instance Functor List {
  map = map_
}


instance Semigroup (List a) {
  assoc = (l1, l2) => [...l1, ...l2]
}


instance Monoid (List a) {
  mappend = (l1, l2) => [...l1, ...l2]
  mempty = []
}


nth :: Integer -> List a -> Maybe a
export nth = (index, list) => where(list) {
  [] =>
    Nothing

  [item, ...rest] =>
    (index == 0)
      ? Just(item)
      : nth(index - 1, rest)
}


reverse :: List a -> List a
export reverse = (xs) => {
  helper :: List a -> List a -> List a
  helper = (acc, l) => where(l) {
    [h, ...t] =>
      helper(push(h, acc), t)
  
    [] =>
      acc
  }

  return helper([], xs)
}


filter :: (a -> Boolean) -> List a -> List a
export filter = (predicate, list) => {
  helper = (acc, xs) => where(xs) {
    [h, ...t] =>
      predicate(h)
        ? helper(push(h, acc), t)
        : helper(acc, t)

    [] =>
      reverse(acc)
  }

  return helper([], list)
}


reject :: (a -> Boolean) -> List a -> List a
export reject = (predicate, list) =>
  filter(complement(predicate), list)
