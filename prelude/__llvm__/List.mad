import type { Maybe } from "./Maybe"

import {} from "./Functor"
import {} from "./Monoid"
import {} from "./PrettyShow"
import { Just, Nothing } from "./Maybe"
import { complement } from "./Function"


push :: a -> List a -> List a
push = extern "MadList_push"
export push

map_ :: (a -> b) -> List a -> List b
map_ = extern "MadList_map"

len :: List a -> Integer
len = extern "MadList_length"
export len

showInteger :: Integer -> String
showInteger = extern "__integerToStr__"


instance Show Integer {
  show = showInteger
}

log :: String -> ()
log = extern "puts"


showWith :: (a -> String) -> List a -> String
showWith = (with, list) => {
  processItems = (processed, items) => {
    return where(items) {
      [first, second, ...rest] =>
        processItems(processed ++ with(first) ++ ", ", push(second, rest))

      [last] =>
        processed ++ with(last)

      [] =>
        ""
    }
  }

  return "[" ++ processItems("", list) ++ "]"
}


instance Show a => Show (List a) {
  show = showWith(show)
}

instance PrettyShow a => PrettyShow (List a) {
  ppShow = showWith(ppShow)
}


instance Functor List {
  map = map_
}


log(show([1, 2, 3]))


// instance Applicative List {
//   pure = (x) => [x]

//   ap = (mf, ma) => pipe(
//     map((f) => map(f, ma)),
//     flatten
//   )(mf)
// }


// instance Monad List {
//   of = pure

//   chain = (f, xs) => pipe(
//     map(f),
//     flatten
//   )(xs)
// }


instance Semigroup (List a) {
  assoc = (l1, l2) => [...l1, ...l2]
}


instance Monoid (List a) {
  mappend = (l1, l2) => [...l1, ...l2]
  mempty = []
}


nth :: Integer -> List a -> Maybe a
export nth = (index, list) => where(list) {
  [] =>
    Nothing

  [item, ...rest] =>
    (index == 0)
      ? Just(item)
      : nth(index - 1, rest)
}


reverse :: List a -> List a
export reverse = (xs) => {
  helper :: List a -> List a -> List a
  helper = (acc, l) => where(l) {
    [h, ...t] =>
      helper(push(h, acc), t)
  
    [] =>
      acc
  }

  return helper([], xs)
}


filter :: (a -> Boolean) -> List a -> List a
export filter = (predicate, list) => {
  helper = (acc, xs) => where(xs) {
    [h, ...t] =>
      predicate(h)
        ? helper(push(h, acc), t)
        : helper(acc, t)

    [] =>
      reverse(acc)
  }

  return helper([], list)
}


reject :: (a -> Boolean) -> List a -> List a
export reject = (predicate, list) =>
  filter(complement(predicate), list)
