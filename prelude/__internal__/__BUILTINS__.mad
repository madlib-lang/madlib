// Eq

#iftarget llvm

arrayToList :: Array a -> List a
arrayToList = extern "madlib__array__toList"

instance Eq a => Eq (Array a) {
  __EQ__ = (a, b) => arrayToList(a) == arrayToList(b)
}

eqByteArray :: ByteArray -> ByteArray -> Boolean
eqByteArray = extern "madlib__bytearray__internal__eq"

instance Eq ByteArray {
  __EQ__ = eqByteArray
}

listLength :: List a -> Integer
listLength = extern "madlib__list__length"

// TODO: should we compare by reference here?
instance Eq (a -> b) {
  __EQ__ = (_, _) => false
}

instance Eq a => Eq (List a) {
  __EQ__ = (a, b) => {
    go = (listA, listB) => where(listA) {
      [] =>
        true

      [valueA, ...xsa] =>
        where (listB) {
          [] =>
            false

          [valueB, ...xsb] =>
            valueA == valueB
              ? go(xsa, xsb)
              : false
        }
    }

    lengthA = listLength(a)
    lengthB = listLength(b)

    return if (lengthA != lengthB) {
      false
    } else {
      go(a, b)
    }
  }
}

instance (Eq a, Eq b) => Eq (Dictionary a b) {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[Dictionary(itemsA), Dictionary(itemsB)] =>
      itemsA == itemsB
  }
}

instance (Eq a, Eq b) => Eq #[a, b] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[#[a1, a2], #[b1, b2]] =>
      a1 == b1 && a2 == b2
  }
}

instance (Eq a, Eq b, Eq c) => Eq #[a, b, c] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[#[a1, a2, a3], #[b1, b2, b3]] =>
      a1 == b1 && a2 == b2 && a3 == b3
  }
}

instance (Eq a, Eq b, Eq c, Eq d) => Eq #[a, b, c, d] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[#[a1, a2, a3, a4], #[b1, b2, b3, b4]] =>
      a1 == b1 && a2 == b2 && a3 == b3 && a4 == b4
  }
}

instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq #[a, b, c, d, e] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[#[a1, a2, a3, a4, a5], #[b1, b2, b3, b4, b5]] =>
      a1 == b1 && a2 == b2 && a3 == b3 && a4 == b4 && a5 == b5
  }
}

instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => Eq #[a, b, c, d, e, f] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[#[a1, a2, a3, a4, a5, a6], #[b1, b2, b3, b4, b5, b6]] =>
      a1 == b1 && a2 == b2 && a3 == b3 && a4 == b4 && a5 == b5 && a6 == b6
  }
}

instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) => Eq #[a, b, c, d, e, f, g] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[#[a1, a2, a3, a4, a5, a6, a7], #[b1, b2, b3, b4, b5, b6, b7]] =>
      a1 == b1
      && a2 == b2
      && a3 == b3
      && a4 == b4
      && a5 == b5
      && a6 == b6
      && a7 == b7
  }
}

instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) => Eq #[a, b, c, d, e, f, g, h] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[#[a1, a2, a3, a4, a5, a6, a7, a8], #[b1, b2, b3, b4, b5, b6, b7, b8]] =>
      a1 == b1
      && a2 == b2
      && a3 == b3
      && a4 == b4
      && a5 == b5
      && a6 == b6
      && a7 == b7
      && a8 == b8
  }
}

instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) => Eq #[a, b, c, d, e, f, g, h, i] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[
      #[a1, a2, a3, a4, a5, a6, a7, a8, a9],
      #[b1, b2, b3, b4, b5, b6, b7, b8, b9]
    ] =>
      a1 == b1
      && a2 == b2
      && a3 == b3
      && a4 == b4
      && a5 == b5
      && a6 == b6
      && a7 == b7
      && a8 == b8
      && a9 == b9
  }
}

instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j) => Eq #[a, b, c, d, e, f, g, h, i, j] {
  __EQ__ = (a, b) => where(#[a, b]) {
    #[
      #[a1, a2, a3, a4, a5, a6, a7, a8, a9, a10],
      #[b1, b2, b3, b4, b5, b6, b7, b8, b9, b10]
    ] =>
      a1 == b1
      && a2 == b2
      && a3 == b3
      && a4 == b4
      && a5 == b5
      && a6 == b6
      && a7 == b7
      && a8 == b8
      && a9 == b9
      && a10 == b10
  }
}

#endif

#iftarget js

#-
const escapeChar = (c) => {
  if (c === '\\') {
    return `\\\\`
  } else if (c === '"') {
    return `\\"`
  } else if (c === '\n') {
    return `\\n`
  } else if (c === '\t') {
    return `\\t`
  } else if (c === '\r') {
    return `\\r`
  } else {
    return c
  }
}
-#

// Show

instance Show Byte {
  show = (n) => #- {
    n = n % 256
    return ('0' + (n < 0 ? 256 + n : n).toString(16)).slice(-2).toUpperCase()
  } -#
}


// TODO: handle the case of very big numbers that are currently displayed like this:
// 2.0120391209380983e+28
instance Show Integer {
  show = (n) => #- "" + n -#
}

instance Show Short {
  show = (n) => #- "" + n -#
}

instance Show Float {
  show = (n) => #- "" + n -#
}

instance Show Char {
  show = (c) => #- {
    if (c === '\\') {
      return `'\\\\'`;
    } else if (c === '\'') {
      return `'\\''`;
    } else if (c === '\n') {
      return `'\\n'`;
    } else if (c === '\t') {
      return `'\\t'`;
    } else if (c === '\r') {
      return `'\\r'`;
    } else {
      return `'${c}'`;
    }
  } -#
}

instance Show String {
  show = (s) => #- `"${s.split('').map(escapeChar).join('')}"` -#
}

#elseif llvm

showByte :: Byte -> String
showByte = extern "madlib__number__internal__showByte"

showInteger :: Integer -> String
showInteger = extern "madlib__number__internal__showInteger"

showFloat :: Float -> String
showFloat = extern "madlib__number__internal__showFloat"

showChar :: Char -> String
showChar = extern "madlib__char__internal__show"

showShort :: Short -> String
showShort = extern "madlib__number__internal__showShort"

showString :: String -> String
showString = extern "madlib__string__internal__show"

instance Show Byte {
  show = showByte
}

instance Show Short {
  show = showShort
}

instance Show Integer {
  show = showInteger
}

instance Show Float {
  show = showFloat
}

instance Show Char {
  show = showChar
}

instance Show String {
  show = showString
}

#endif

instance Show {} {
  show = () => "{}"
}

instance Show Boolean {
  show = (b) => b
    ? "true"
    : "false"
}

instance Show (a -> b) {
  show = () => "[Function]"
}

instance Show a => Show (List a) {
  show = (list) => {
    showItems = (_list, acc) => where(_list) {
      [] =>
        acc

      [last] =>
        acc == ""
          ? show(last)
          : `${acc}, ${show(last)}`

      [item, ...next] =>
        acc == ""
          ? showItems(next, show(item))
          : showItems(next, `${acc}, ${show(item)}`)
    }

    return `[${showItems(list, "")}]`
  }
}

#iftarget js

Dictionary :: List #[k, v] -> Dictionary k v
Dictionary = (items) => #- ({
  __constructor: "Dictionary",
  __args: [items],
}) -#

#elseif llvm

Dictionary :: List #[k, v] -> Dictionary k v
Dictionary = extern "madlib__dictionary__typeConstructor"

#endif

instance (Show a, Show b) => Show (Dictionary a b) {
  show = (dict) => {
    showItems = (items, acc) => where(items) {
      [] =>
        ""

      [#[key, value]] =>
        acc == ""
          ? `${show(key)}: ${show(value)}`
          : `${acc}, ${show(key)}: ${show(value)}`

      [#[key, value], ...next] =>
        acc == ""
          ? showItems(next, `${show(key)}: ${show(value)}`)
          : showItems(next, `${acc}, ${show(key)}: ${show(value)}`)
    }

    return where(dict) {
      Dictionary(items) =>
        `{{ ${showItems(items, "")} }}`
    }
  }
}

#iftarget js

instance Show ByteArray {
  show = (byteArray) => #- {
    let s = ''
    let h = '0123456789ABCDEF'
    byteArray.forEach((v, index) => {
      if ((index + 1) % 9 === 0) { s += ' ' }
      s += h[v >> 4] + h[v & 15]
    })
    return `ByteArray(${s})`
  } -#
}

#elseif llvm

showByteArray :: ByteArray -> String
showByteArray = extern "madlib__bytearray__internal__show"

instance Show ByteArray {
  show = showByteArray
}

#endif

#iftarget js

arrayToList :: Array a -> List a
export arrayToList = (array) => #- {
  let list = {}
  let start = list

  array.forEach(item => {
    list = list.n = { v: item, n: null }
  })

  return start.n
} -#

instance Show a => Show (Array a) {
  show = (array) => `Array(${show(arrayToList(array))})`
}

#elseif llvm

instance Show a => Show (Array a) {
  show = (array) => `Array(${show(arrayToList(array))})`
}

#endif

instance (Show a, Show b) => Show #[a, b] {
  show = (tuple) => where(tuple) {
    #[a, b] =>
      `#[${show(a)}, ${show(b)}]`
  }
}

instance (Show a, Show b, Show c) => Show #[a, b, c] {
  show = (tuple) => where(tuple) {
    #[a, b, c] =>
      `#[${show(a)}, ${show(b)}, ${show(c)}]`
  }
}

instance (Show a, Show b, Show c, Show d) => Show #[a, b, c, d] {
  show = (tuple) => where(tuple) {
    #[a, b, c, d] =>
      `#[${show(a)}, ${show(b)}, ${show(c)}, ${show(d)}]`
  }
}

instance (
  Show a,
  Show b,
  Show c,
  Show d,
  Show e
) => Show #[a, b, c, d, e] {
  show = (tuple) => where(tuple) {
    #[a, b, c, d, e] =>
      `#[${show(a)}, ${show(b)}, ${show(c)}, ${show(d)}, ${show(e)}]`
  }
}

instance (
  Show a,
  Show b,
  Show c,
  Show d,
  Show e,
  Show f
) => Show #[a, b, c, d, e, f] {
  show = (tuple) => where(tuple) {
    #[a, b, c, d, e, f] =>
      `#[${show(a)}, ${show(b)}, ${show(c)}, ${show(d)}, ${show(e)}, ${show(f)}]`
  }
}

instance (
  Show a,
  Show b,
  Show c,
  Show d,
  Show e,
  Show f,
  Show g
) => Show #[a, b, c, d, e, f, g] {
  show = (tuple) => where(tuple) {
    #[a, b, c, d, e, f, g] =>
      `#[${show(a)}, ${show(b)}, ${show(c)}, ${show(d)}, ${show(e)}, ${show(f)}, ${show(g)}]`
  }
}

instance (
  Show a,
  Show b,
  Show c,
  Show d,
  Show e,
  Show f,
  Show g,
  Show h
) => Show #[a, b, c, d, e, f, g, h] {
  show = (tuple) => where(tuple) {
    #[a, b, c, d, e, f, g, h] =>
      `#[${show(a)}, ${show(b)}, ${show(c)}, ${show(d)}, ${show(e)}, ${show(f)}, ${show(g)}, ${show(h)}]`
  }
}

instance (
  Show a,
  Show b,
  Show c,
  Show d,
  Show e,
  Show f,
  Show g,
  Show h,
  Show i
) => Show #[a, b, c, d, e, f, g, h, i] {
  show = (tuple) => where(tuple) {
    #[a, b, c, d, e, f, g, h, i] =>
      `#[${show(a)}, ${show(b)}, ${show(c)}, ${show(d)}, ${show(e)}, ${show(f)}, ${show(g)}, ${show(h)}, ${show(i)}]`
  }
}
