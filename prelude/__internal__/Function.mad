/**
 * Wraps a predicate function and make it return the inverse. So if for a value
 * the function would normally return true, after "complemented" it would return
 * false and vice versa.
 *
 * @since 0.0.5
 * @example
 * complement((x) => x % 2 == 0)(2) // false
 */
complement :: (a -> Boolean) -> (a -> Boolean)
export complement = (fn) => ((x) => (!fn(x)))


/**
 * It always returns the first supplied parameter no matter what. It is especially
 * practical during function composition when you want to discard whatever value
 * is passed to a function and always return the same thing.
 *
 * @since 0.0.5
 * @example
 * always(true, "1")            // true
 * map(always(true), [1, 2 ,3]) // [true, true, true]
 */
always :: a -> b -> a
export always = (a, b) => (a)

identity :: a -> a
export identity = (a) => (a)

equals :: a -> a -> Boolean
export equals = (val, a) => val == a

ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b
export ifElse = (predicate, truthy, falsy, value) => predicate(value)
  ? truthy(value)
  : falsy(value)

when :: (a -> Boolean) -> (a -> a) -> a -> a
export when = (predicate, truthy, value) =>
  ifElse(predicate, truthy, always(value), value)

not :: Boolean -> Boolean
export not = (b) => !b

flip :: (a -> b -> c) -> (b -> a -> c)
export flip = (f) => ((b, a) => f(a, b)) 


#-
const nativeMemoize = (fn) => {
  let cache = {};
  return (a) => {
    const key = JSON.stringify(a)
    if (!cache[key]) {
      cache[key] = fn.apply(this, [a])
    }
    return cache[key]
  }
}
-#

memoize :: (a -> b) -> (a -> b)
export memoize = (fn) => #- nativeMemoize(fn) -#

#-
const nativeMemoize2 = (fn) => {
  let cache = {};
  return __curry__((a, b) => {
    const key = JSON.stringify([a, b])
    if (!cache[key]) {
      cache[key] = fn.apply(this, [a, b])
    }
    return cache[key]
  })
}
-#

memoize2 :: (a -> b -> c) -> (a -> b -> c)
export memoize2 = (fn) => #- nativeMemoize2(fn) -#

#-
const nativeMemoize3 = (fn) => {
  let cache = {};
  return __curry__((a, b, c) => {
    const key = JSON.stringify([a, b, c])
    if (!cache[key]) {
      cache[key] = fn.apply(this, [a, b, c])
    }
    return cache[key]
  })
}
-#

memoize3 :: (a -> b -> c -> d) -> (a -> b -> c -> d)
export memoize3 = (fn) => #- nativeMemoize3(fn) -#
