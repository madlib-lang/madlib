import type { Maybe } from "Maybe"
import {} from "Monoid"
import { MORE, LESS, EQUAL } from "Compare"
import { Just, Nothing } from "Maybe"


instance Semigroup String {
  assoc = (a, b) => a ++ b
}

instance Monoid String {
  mempty = ""
  mappend = (a, b) => a ++ b
}

#iftarget js

instance Comparable String {
  compare = (a, b) => #- a > b ? MORE : a === b ? EQUAL : LESS -#
}

#elseif llvm

import type { ComparisonResult } from "Compare"

stringCompare :: String -> String -> ComparisonResult
stringCompare = extern "madlib__string__compare"

instance Comparable String {
  compare = stringCompare
}

#endif


#iftarget js

toLower :: String -> String
export toLower = (s) => #- s.toLowerCase() -#

toUpper :: String -> String
export toUpper = (s) => #- s.toUpperCase() -#

replace :: String -> String -> String -> String
export replace = (regex, replacing, input) => (#-
  input.replace(new RegExp(regex), replacing)
-#)

split :: String -> String -> List String
export split = (separator, str) => #- {
  const items = str.split(separator)

  if (items.length === 0) {
    return null
  }

  let current = {}
  let output = current
  items.forEach((item) => {
    current = current.n = {}
    current.v = item
  })
  current.n = null

  return output.n
} -#

lines :: String -> List String
export lines = split("\n")

#endif

#iftarget js

toList :: String -> List Char
export toList = (str) => #- {
  let result = {}
  let current = result
  str.split('').forEach(c => {
    current = current.n = { v: c, n: null }
  })
  return result.n
} -#

fromList :: List Char -> String
export fromList = (list) => #- {
  let chars = []
  while (list !== null) {
    chars.push(list.v)
    list = list.n
  }
  return chars.join('')
} -#


#elseif llvm

toList :: String -> List Char
export toList = extern "madlib__string__toList"

fromList :: List Char -> String
export fromList = extern "madlib__string__fromList"

#endif

#iftarget js

mapChars :: (Char -> Char) -> String -> String
export mapChars = (f, s) => #- s.split("").map(f).join("") -#

#elseif llvm

mapChars :: (Char -> Char) -> String -> String
export mapChars = extern "madlib__string__mapChars"

#endif

#iftarget js

reduceChars :: (a -> String -> a) -> a -> String -> a
export reduceChars = (f, initial, s) => #- s.split("").reduce((a, b) => f(a)(b), initial) -#

slice :: Integer -> Integer -> String -> String
export slice = (start, end, s) => #- s.slice(start, end) -#

isEmpty :: String -> Boolean
export isEmpty = (s) => s == ""

nthChar :: Integer -> String -> Maybe String
export nthChar = (n, s) => #-{
  const c = s[n]
  return !!c ? Just(c) : Nothing
}-#

firstChar :: String -> Maybe String
export firstChar = nthChar(0)

lastChar :: String -> Maybe String
export lastChar = (s) => nthChar(len(s) - 1, s)

drop :: Integer -> String -> String
export drop = (n, s) => slice(n, len(s), s)

dropLast :: Integer -> String -> String
export dropLast = (n, s) => slice(0, -n, s)

trim :: String -> String
export trim = (s) => #- s.trim() -#

trimStart :: String -> String
export trimStart = (s) => #- s.trimStart() -#

trimEnd :: String -> String
export trimEnd = (s) => #- s.trimEnd() -#

/**
 * Returns true if the character is a letter, false otherwise. Note that if the
 * input contains more than one character, false is returned.
 */
isLetter :: String -> Boolean
export isLetter = (s) => #-{
  if (s.length !== 1) {
    return false
  }

  return RegExp(/^\p{L}/,'u').test(s)
}-#

len :: String -> Integer
export len = (s) => #- s.length -#

/**
 * Returns true if the character is a digit, false otherwise. Note that if the
 * input contains more than one character, false is returned.
 */
isDigit :: String -> Boolean
export isDigit = (s) => len(s) != 1
  ? false
  : s == "0" ||
    s == "1" ||
    s == "2" ||
    s == "3" ||
    s == "4" ||
    s == "5" ||
    s == "6" ||
    s == "7" ||
    s == "8" ||
    s == "9"

repeat :: Integer -> String -> String
export repeat = (n, s) => #- s.repeat(n) -#

match :: String -> String -> Boolean
export match = (regex, input) => #- input.match(regex) -#

#endif
