import type { Maybe } from "Maybe"
import {} from "Monoid"
import { MORE, LESS, EQUAL } from "Compare"
import { Just, Nothing } from "Maybe"
import List from "List"


instance Semigroup String {
  assoc = (a, b) => a ++ b
}

instance Monoid String {
  mempty = ""
  mconcat = (a, b) => a ++ b
}

#iftarget js

instance Comparable String {
  compare = (a, b) => #- a > b ? MORE : a === b ? EQUAL : LESS -#
}

#elseif llvm

import type { ComparisonResult } from "Compare"

stringCompare :: String -> String -> ComparisonResult
stringCompare = extern "madlib__string__compare"

instance Comparable String {
  compare = stringCompare
}

#endif


#iftarget js

toLower :: String -> String
export toLower = (s) => #- s.toLowerCase() -#

toUpper :: String -> String
export toUpper = (s) => #- s.toUpperCase() -#

replace :: String -> String -> String -> String
export replace = (regex, replacing, input) => (#-
  input.replace(new RegExp(regex), replacing)
-#)

#endif

#iftarget js

split :: String -> String -> List String
export split = (separator, str) => #- {
  const items = str.split(separator)

  if (items.length === 0) {
    return null
  }

  let current = {}
  let output = current
  items.forEach((item) => {
    current = current.n = {}
    current.v = item
  })
  current.n = null

  return output.n
} -#

#elseif llvm

split :: String -> String -> List String
export split = extern "madlib__string__split"

#endif

lines :: String -> List String
export lines = split("\n")


/**
 * Joins a list with a separator and returns a String.
 *
 * IMPORTANT:
 * When coming from JS, beware that there is a small difference with Array.prototype.join.
 * In JS, join relies on its dynamic nature and accepts any type as being valid, and transforms it
 * to a string for you. In Madlib you need to provide an instance of Show for your custom types, and
 * for Madlib types (eg. tuples, List, Boolean, Maybe) it uses the Show instance defined for them.
 *
 * @since 0.0.5
 * @example
 * join(" and ", ["cats", "dogs"])   // "cats and dogs"
 * join("", ["one", "two", "three"]) // "onetwothree"
 */
join :: String -> List String -> String
export join = (a, xs) => pipe(
  List.intercalate(a),
  List.reduce(mconcat, "")
)(xs)


/**
 * Transform a List of Strings into a single String,
 * by adding newlines between each item in the List.
 *
 * @since 0.0.5
 * @example
 * unlines(["line1", "line2", "line3"]) // "line1\nline2\nline3"
 */
unlines :: List String -> String
export unlines = join("\n")


#iftarget js

toList :: String -> List Char
export toList = (str) => #- {
  let result = {}
  let current = result
  str.split('').forEach(c => {
    current = current.n = { v: c, n: null }
  })
  return result.n
} -#

fromList :: List Char -> String
export fromList = (list) => #- {
  let chars = []
  while (list !== null) {
    chars.push(list.v)
    list = list.n
  }
  return chars.join('')
} -#


#elseif llvm

toList :: String -> List Char
export toList = extern "madlib__string__toList"

fromList :: List Char -> String
export fromList = extern "madlib__string__fromList"

#endif

#iftarget js

mapChars :: (Char -> Char) -> String -> String
export mapChars = (f, s) => #- s.split("").map(f).join("") -#

#elseif llvm

mapChars :: (Char -> Char) -> String -> String
export mapChars = extern "madlib__string__mapChars"

#endif

#iftarget js

reduceChars :: (a -> String -> a) -> a -> String -> a
export reduceChars = (f, initial, s) => #- s.split("").reduce((a, b) => f(a)(b), initial) -#

#endif

#iftarget js

slice :: Integer -> Integer -> String -> String
export slice = (start, end, s) => #- s.slice(start, end) -#

#elseif llvm

slice :: Integer -> Integer -> String -> String
export slice = extern "madlib__string__slice"

#endif

#iftarget js

isEmpty :: String -> Boolean
export isEmpty = (s) => s == ""

nthChar :: Integer -> String -> Maybe String
export nthChar = (n, s) => #-{
  const c = s[n]
  return !!c ? Just(c) : Nothing
}-#

firstChar :: String -> Maybe String
export firstChar = nthChar(0)

lastChar :: String -> Maybe String
export lastChar = (s) => nthChar(length(s) - 1, s)

drop :: Integer -> String -> String
export drop = (n, s) => slice(n, length(s), s)

dropLast :: Integer -> String -> String
export dropLast = (n, s) => slice(0, -n, s)

trim :: String -> String
export trim = (s) => #- s.trim() -#

trimStart :: String -> String
export trimStart = (s) => #- s.trimStart() -#

trimEnd :: String -> String
export trimEnd = (s) => #- s.trimEnd() -#

/**
 * Returns true if the character is a letter, false otherwise. Note that if the
 * input contains more than one character, false is returned.
 */
isLetter :: String -> Boolean
export isLetter = (s) => #-{
  if (s.length !== 1) {
    return false
  }

  return RegExp(/^\p{L}/,'u').test(s)
}-#


#endif

#iftarget js

length :: String -> Integer
export length = (s) => #- s.length -#

#elseif llvm

length :: String -> Integer
export length = extern "madlib__string__length"

#endif

#iftarget js

/**
 * Returns true if the character is a digit, false otherwise. Note that if the
 * input contains more than one character, false is returned.
 */
isDigit :: String -> Boolean
export isDigit = (s) => length(s) != 1
  ? false
  : s == "0" ||
    s == "1" ||
    s == "2" ||
    s == "3" ||
    s == "4" ||
    s == "5" ||
    s == "6" ||
    s == "7" ||
    s == "8" ||
    s == "9"

repeat :: Integer -> String -> String
export repeat = (n, s) => #- s.repeat(n) -#

match :: String -> String -> Boolean
export match = (regex, input) => #- input.match(regex) -#

#endif
