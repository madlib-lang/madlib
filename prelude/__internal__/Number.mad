import type { Maybe } from "Maybe"
import { EQUAL, LESS, MORE } from "Compare"
import {} from "Scan"
import {} from "Show"


instance Comparable Integer {
  compare = (a, b) => a > b ? MORE : a == b ? EQUAL : LESS
}

instance Comparable Byte {
  compare = (a, b) => a > b ? MORE : a == b ? EQUAL : LESS
}

instance Comparable Float {
  compare = (a, b) => a > b ? MORE : a == b ? EQUAL : LESS
}


instance Show Integer {
  show = inspect
}

instance Show Byte {
  show = inspect
}

instance Show Float {
  show = inspect
}


#iftarget js

import { Just, Nothing } from "Maybe"

_scanInteger :: (Integer -> Maybe Integer) -> Maybe Integer -> String -> Maybe Integer
_scanInteger = (just, nothing, str) => (#- {
  const n = parseInt(str)
  return isNaN(n) ? nothing : just(n)
} -#)

scanInteger = _scanInteger(Just, Nothing)

_scanFloat :: (Float -> Maybe Float) -> Maybe Float -> String -> Maybe Float
_scanFloat = (just, nothing, str) => (#- {
  const n = parseFloat(str)
  return isNaN(n) ? nothing : just(n)
} -#)

scanFloat = _scanFloat(Just, Nothing)

_scanByte :: (Byte -> Maybe Byte) -> Maybe Byte -> String -> Maybe Byte
_scanByte = (just, nothing, str) => (#- {
  const n = parseInt(str)
  return isNaN(n) ? nothing : just(n)
} -#)

scanByte = _scanByte(Just, Nothing)

#elseif llvm

scanInteger :: String -> Maybe Integer
scanInteger = extern "madlib__number__scanInteger"

scanFloat :: String -> Maybe Float
scanFloat = extern "madlib__number__scanFloat"

scanByte :: String -> Maybe Byte
scanByte = extern "madlib__number__scanByte"

#endif

instance Scan Integer {
  scan = scanInteger
}

instance Scan Float {
  scan = scanFloat
}

instance Scan Byte {
  scan = scanByte
}


// conversions
#iftarget js

integerToFloat :: Integer -> Float
export integerToFloat = (a) => #- { return a } -#

integerToByte :: Integer -> Byte
export integerToByte = (a) => #- { return Uint8Array.from([a])[0] } -#

byteToFloat :: Byte -> Float
export byteToFloat = (a) => #- { return a } -#

byteToInteger :: Byte -> Integer
export byteToInteger = (a) => #- { return a } -#

floatToInteger :: Float -> Integer
export floatToInteger = (a) => #- { return Math.trunc(a) } -#

floatToByte :: Float -> Byte
export floatToByte = (a) => #- { return Uint8Array.from([Math.trunc(a)])[0] } -#

#elseif llvm

integerToFloat :: Integer -> Float
export integerToFloat = extern "madlib__number__intToFloat"

integerToByte :: Integer -> Byte
export integerToByte = extern "madlib__number__intToByte"

byteToFloat :: Byte -> Float
export byteToFloat = extern "madlib__number__byteToFloat"

byteToInteger :: Byte -> Integer
export byteToInteger = extern "madlib__number__byteToInt"

floatToInteger :: Float -> Integer
export floatToInteger = extern "madlib__number__floatToInt"

floatToByte :: Float -> Byte
export floatToByte = extern "madlib__number__floatToByte"

#endif

#iftarget js

// TODO: implement for llvm backend
/**
 * Formats a a number given as the first parameter to a string containing the
 * amount of numbers after the . given by the second parameter.
 * @since 0.4.0
 * @example
 * formatDecimal(3.14159, 2) // "3.14"
 */
formatDecimal :: Number a => a -> Float -> String
export formatDecimal = (a, x) => #-{
  const n = x.toFixed(a)
  return isNaN(n) ? "0" : n
}-#

#endif
