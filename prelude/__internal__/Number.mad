import {} from "Show"
import {} from "Read"
import type { Maybe } from "Maybe"
import { Just, Nothing } from "Maybe"

#iftarget js
instance Show Float {
  show = (x) => #- x.toString() -#
}
#elseif llvm
showFloat :: Float -> String
showFloat = extern "madlib__number__internal__showFloat"

instance Show Float {
  show = showFloat
}
#endif

#iftarget js
instance Show Integer {
  show = (x) => #- x.toString() -#
}
#elseif llvm
showInteger :: Integer -> String
showInteger = extern "madlib__number__internal__showInteger"

instance Show Integer {
  show = showInteger
}


showByte :: Byte -> String
showByte = extern "madlib__number__internal__showByte"


instance Show Byte {
  show = showByte
}
#endif

#iftarget js
instance Read Float {
  read = fromString
}

instance Read Integer {
  read = fromString
}

intToFloat :: Integer -> Float
export intToFloat = (x) => #- x -#

fromString :: Number a => String -> Maybe a
export fromString = (str) => (#- {
  const n = parseFloat(str)
  return isNaN(n) ? Nothing : Just(n)
} -#)


/**
 * Formats a a number given as the first parameter to a string containing the
 * amount of numbers after the . given by the second parameter.
 * @since 0.4.0
 * @example
 * formatDecimal(3.14159, 2) // "3.14"
 */
formatDecimal :: Number a => a -> Float -> String
export formatDecimal = (a, x) => #-{
  const n = x.toFixed(a)
  return isNaN(n) ? "0" : n
}-#

// TODO: Move to List and write with recursion
range :: Integer -> Integer -> List Integer
export range = (a, b) => #-{
  const out = []
  let x = a
  while (x < b) {
    out.push(x)
    x += 1
  }
  return out
}-#
#endif
