import {} from "Monad"
import {} from "Show"


/**
 * Maybe is one of the major data types in functional programming and serves to
 * represent things that have the possibility of not existing or potentially failing.
 * Any computation that could fail or return anything like "null, nil, undefined, .." in
 * other procedural/OO languages would benefit from relying on Maybe instead.
 */


/**
 * Maybe is a type that serve to represent values that can potentially
 * not exist. It's used for things like List.nth or List.last. When the
 * item you're looking for is not in the list a Nothing is returned instead
 * of "Just" the item.
 *
 * @since 0.0.5
 * @example
 * Just(3)     // Just(3) :: Maybe Number
 * Just(false) // Just(false) :: Maybe Boolean
 * Nothing     // Nothing :: Maybe a
 */
export type Maybe a
  = Just a
  | Nothing


/**
 * The Functor instance of Maybe maps over the value only if a value exists,
 * understand it is a Just. Otherwise it returns Nothing.
 *
 * @since 0.0.6
 * @example
 * map((x) => x + 1, Just(0)) // Just(1)
 * map((x) => x + 1, Nothing) // Nothing
 */
instance Functor Maybe {
  map = (f) => where
    is Just x : Just(f(x))
    is Nothing: Nothing
}


/**
 * The Applicative instance of Maybe defines ap that applies a function wrapped in
 * a Maybe to a value wrapped in a Maybe. If one of the two is a Nothing, it
 * returns Nothing.
 *
 * @since 0.0.6
 * @example
 * ap(Just((x) => x + 1), Just(0)) // Just(1)
 * ap(Just((x) => x + 1), Nothing) // Nothing
 * ap(Nothing, Just(3))            // Nothing
 */
instance Applicative Maybe {
  pure = Just
  ap = (mf, mx) => where(<mf, mx>)
    is <Just f, Just x>: pure(f(x))
    is _               : Nothing
}


/**
 * The Monad instance of Maybe defines chain that applies a function that returns a
 * Maybe to a value wrapped in a Maybe.
 *
 * @since 0.0.6
 * @example
 * chain((x) => Just(x + 1), Just(1)) // Just(2)
 */
instance Monad Maybe {
  of = pure
  chain = (f, m) => (where(m) {
    is Just x : f(x)
    is Nothing: Nothing
  })
}


/**
 * The Show instance of Maybe returns Just or Nothing, following by the showed
 * value it contains.
 *
 * @since 0.0.6
 * @example
 * show(Just(3))                   // "Just 3"
 * show((Nothing :: Maybe Number)) // "Nothing"
 */
instance Show a => Show (Maybe a) {
  show = where
    is Just a : "Just " ++ show(a)
    is Nothing: "Nothing"
}


/**
 * fromMaybe returns the value contained in the Maybe if it is a Just, or the
 * fallback value otherwise.
 *
 * @since 0.0.5
 * @example
 * fromMaybe(3, Just(4)) // 4
 * fromMaybe(3, Nothing) // 3
 */
fromMaybe :: a -> Maybe a -> a
export fromMaybe = (or) => where
  is Just a : a
  is Nothing: or
