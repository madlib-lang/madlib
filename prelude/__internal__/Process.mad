import type { Maybe } from "Maybe"
import type { Wish } from "Wish"

import { Wish } from "Wish"
import Dictionary from "Dictionary"
import String from "String"
import List from "List"
import { fromMaybe } from "Maybe"


export alias CommandResult = {
  exitCode :: Integer,
  stdout :: String,
  stderr :: String  
}

export alias CommandOptions = {
  cwd :: String,
  env :: Dictionary String String
}


makeCommandResult :: Integer -> String -> String -> CommandResult
makeCommandResult = (exitCode, stdout, stderr) => ({
  exitCode,
  stdout,
  stderr,
})

#iftarget js

#- import { spawn as spawnJs } from "child_process" -#

// TODO: change API to String -> List String -> Options -> Wish CommandResult CommandResult
// to match the api from libuv and node
exec :: String -> List String -> CommandOptions -> Wish CommandResult CommandResult
export exec = (command, args, options) => Wish((bad, good) => #- {
  let stdoutChunks = []
  let stderrChunks = []

  const env = {};
  const envItems = __listToJSArray__(options.env.__args[0]);
  envItems.forEach(([key, value]) => { env[key] = value; })

  const proc = spawnJs(
    command,
    __listToJSArray__(args),
    {
      cwd: options.cwd,
      env: envItems.length > 0 ? env : process.env,
    }
  )

  proc.stdout.on("data", (chunk) => {
    stdoutChunks.push(Buffer.from(chunk, 'binary'));
  })

  proc.stderr.on("data", (chunk) => {
    stderrChunks.push(Buffer.from(chunk, 'binary'));
  })

  proc.on('close', (code) => {
    const stdoutBuffer = Buffer.concat(stdoutChunks)
    const stderrBuffer = Buffer.concat(stderrChunks)

    if (code === 0) {
      good(makeCommandResult(0)(stdoutBuffer.toString())(stderrBuffer.toString()))
    } else {
      bad(makeCommandResult(code)(stdoutBuffer.toString())(stderrBuffer.toString()))
    }
  });
} -#)

#-
const makeArgs = () => {
  let list = {}
  let start = list
  Object.keys(process.argv.slice(0)).forEach((key) => {
    list = list.n = { v: process.argv[key], n: null }
  }, {})
  return {
    n: start.n.n.n,
    v: start.n.n.v
  }
}
-#


Argv :: List String
export Argv = #- makeArgs() -#


#-
const buildEnvImpl = (dict) => {
  let list = {}
  let start = list
  Object.keys(process.env).forEach((key) => {
    list = list.n = { v: [key, process.env[key]], n: null }
  }, {})
  return Dictionary.fromList(dict)(start.n)
}
-#

envFFI :: Comparable a => Dictionary a String
envFFI = extern "buildEnvImpl"

Env :: Dictionary String String
export Env = envFFI



getCurrentWorkingDirectory :: a -> String
export getCurrentWorkingDirectory = () => #- process.cwd() -#


exit :: Integer -> {}
export exit = #- process.exit -#

#elseif llvm
import { canonicalizePath, joinPath } from "FilePath/Posix"


getCurrentPathFFI :: {} -> String
getCurrentPathFFI = extern "madlib__process__internal__getCurrentPath"


getCurrentWorkingDirectory :: a -> String
export getCurrentWorkingDirectory = () => getCurrentPathFFI()


getArgsFFI :: {} -> List String
getArgsFFI = extern "madlib__process__internal__getArgs"


Argv :: List String
export Argv = where (getArgsFFI()) {
  [exePath, ...args] =>
    String.take(2, exePath) == "./"
      ? [canonicalizePath(joinPath([getCurrentWorkingDirectory(), exePath])), ...args]
      : [exePath, ...args]
}


getEnvFFI :: {} -> List #[String, String]
getEnvFFI = extern "madlib__process__internal__getEnv"


Env :: Dictionary String String
export Env = Dictionary.fromList(getEnvFFI({}))


execFFI :: String -> List String -> CommandOptions -> (Integer -> String -> String -> {}) -> {}
execFFI = extern "madlib__process__exec"


// TODO: change API to String -> List String -> Options -> Wish CommandResult CommandResult
// to match the api from libuv and node
exec :: String -> List String -> CommandOptions -> Wish CommandResult CommandResult
export exec = (command, args, options) => Wish((bad, good) =>
  execFFI(
    command,
    args,
    options,
    (exitCode, stdout, stderr) =>
      exitCode != 0
        ? bad(makeCommandResult(exitCode, stdout, stderr))
        : good(makeCommandResult(exitCode, stdout, stderr))
  )
)

exit :: Integer -> {}
export exit = extern "exit"

#endif

getExecutablePath :: a -> String
export getExecutablePath = () => fromMaybe("", List.nth(0, Argv))

getEnv :: String -> Maybe String
export getEnv = (name) => Dictionary.get(name, Env)

DEFAULT_COMMAND_OPTIONS :: CommandOptions
export DEFAULT_COMMAND_OPTIONS = {
  cwd: "./",
  env: {{}},
}
