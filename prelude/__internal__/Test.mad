import Wish from "Wish"
import IO from "IO"
import { always, equals, ifElse, when } from "Function"
import List from "List"
import String from "String"
import Dictionary from "Dictionary"
import Tuple from "Tuple"
import Process from "Process"
import FilePath from "FilePath/Posix"
import Math from "Math"
import { Just, Nothing, fromMaybe } from "Maybe"
import {} from "Number"


moveCursorUpCode :: Integer -> String
moveCursorUpCode = (lines) => `\x1b[${inspect(lines)}A`


IS_COLOR_ENABLED :: Boolean
IS_COLOR_ENABLED = do {
  noColor = Process.getEnv("NO_COLOR")
  return noColor == Just("") || noColor == Nothing
}


PREFIX_RUNS :: String
PREFIX_RUNS = IS_COLOR_ENABLED
  ? IO.ansiColor([IO.ansi.FGBlack, IO.ansi.BGBrightYellow], " RUNS ")
  : "RUNS "

PREFIX_PASS :: String
PREFIX_PASS = IS_COLOR_ENABLED
  ? IO.ansiColor([IO.ansi.FGBlack, IO.ansi.BGBrightGreen], " PASS ")
  : "PASS "

PREFIX_FAIL :: String
PREFIX_FAIL = IS_COLOR_ENABLED
  ? IO.ansiColor([IO.ansi.FGBlack, IO.ansi.BGBrightRed], " FAIL ")
  : "FAIL "

CHAR_CHECK :: String
CHAR_CHECK = "✓"

CHAR_CROSS :: String
CHAR_CROSS = "×"

EMPTY_REPORT :: TestReport
EMPTY_REPORT = TestReport("", 0, 0, 0)

CWD :: String
CWD = Process.getCurrentWorkingDirectory()


// Result collector

// SuiteResult(total, succeeded, failed)
type SuiteResult = SuiteResult(Integer, Integer, Integer)

type TestResult
  = Success
  | Failure

makeResultCollector :: {} -> {
  getResults :: {} -> Dictionary String SuiteResult,
  setResults :: Dictionary String SuiteResult -> {}
}
makeResultCollector = () => {
  results = {{}}

  getResults = () => results

  setResults = (newResults) => {
    results = newResults
  }

  return { getResults, setResults }
}

collector :: {
  getResults :: {} -> Dictionary String SuiteResult,
  setResults :: Dictionary String SuiteResult -> {}
}
collector = makeResultCollector()


// Test API

export type AssertionError a
  = AssertionError(a, a)
  | Error(a)
  | ErrorWithMessage(String)
  | NotImplemented


// Contains the accumulated String to be displayed,
// the amount of tests run, the amount of successful tests,
// and the amount of failed tests
type TestReport = TestReport(String, Integer, Integer, Integer)


getMessage :: TestReport -> String
getMessage = where {
  TestReport(str, _, _, _) =>
    str
}


getTotal :: TestReport -> Integer
getTotal = where {
  TestReport(_, total, _, _) =>
    total
}


getSuccessCount :: TestReport -> Integer
getSuccessCount = where {
  TestReport(_, _, success, _) =>
    success
}


getFailureCount :: TestReport -> Integer
getFailureCount = where {
  TestReport(_, _, _, failed) =>
    failed
}


failureReport :: String -> TestReport
failureReport = (message) =>
  TestReport(message, 1, 0, 1)


successReport :: String -> TestReport
successReport = (_) =>
  TestReport("", 1, 1, 0)


mergeReports :: TestReport -> TestReport -> TestReport
mergeReports = (t1, t2) => TestReport(
  getMessage(t1) ++ getMessage(t2),
  getTotal(t1) + getTotal(t2),
  getSuccessCount(t1) + getSuccessCount(t2),
  getFailureCount(t1) + getFailureCount(t2)
)


assertEquals :: Eq a => a -> a -> Wish.Wish (AssertionError a) {}
export assertEquals = (actual, expected) => actual == expected
  ? of({})
  : Wish.bad(AssertionError(expected, actual))


test :: Inspect a => String -> (String -> Wish.Wish (AssertionError a) {}) -> Wish.Wish String String
export test = (description, testImpl) => pipe(
  (run) => run(description),
  map((_) => IO.text.brightGreen(`${CHAR_CHECK} ${description}\n`)),
  Wish.mapRej(
    where {
      AssertionError(expected, actual) => 
        IO.red(`${CHAR_CROSS} ${description}`)
        ++ "\n  expected:\n    "
        ++ IO.text.brightGreen(inspect(expected))
        ++ "\n  actual:\n    "
        ++ IO.text.brightRed(inspect(actual))
        ++ "\n"

      ErrorWithMessage(message) =>
        IO.red(`${CHAR_CROSS} ${message}\n`)

      Error(err) =>
        IO.red(`${CHAR_CROSS} ${inspect(err)}`)

      NotImplemented =>
        IO.red(`${CHAR_CROSS} not implemented`)
    }
  )
)(testImpl)


generateReportSuiteEndMessage :: List (Wish.Wish String String) -> String
generateReportSuiteEndMessage = pipe(
  List.length,
  ifElse(
    equals(0),
    always("No test found\n\n"),
    always("")
  )
)


prepareSuitePath :: String -> String
prepareSuitePath = (suitePath) => {
  cwdParts = FilePath.splitPath(CWD)
  partIndex = 0

  return pipe(
    FilePath.splitPath,
    List.dropWhile((part) => {
      justPart = pipe(
        FilePath.dropTrailingPathSeparator,
        Just
      )(part)
      justCwdPart = pipe(
        List.nth(partIndex),
        map(FilePath.dropTrailingPathSeparator)
      )(cwdParts)
      drop = justPart == justCwdPart
      partIndex = partIndex + 1
      return drop
    }),
    (parts) => {
      path = pipe(List.init, FilePath.joinPath, mconcat($, "/"), when(always(IS_COLOR_ENABLED), IO.grey))(parts)
      fileName = pipe(
        List.last,
        fromMaybe("")
      )(parts)

      return path ++ fileName
    }
  )(suitePath)
}


spaces :: Integer -> String
spaces = (amount) => pipe(
  List.repeat(' '),
  String.fromList
)(amount)


printSuiteResults :: Dictionary String SuiteResult -> {}
printSuiteResults = (results) => {
  pipe(
    Dictionary.toList,
    map(
      where {
        #[suitePath, SuiteResult(total, success, failed)] =>
          do {
            counts = `${inspect(success + failed)}/${inspect(total)}`
            preparedSuitePath = prepareSuitePath(suitePath)
            coloredCounts =
              if (IS_COLOR_ENABLED) {
                failed > 0
                  ? IO.text.brightRed(counts)
                  : IO.text.brightGreen(counts)
              } else {
                counts
              }
            prefix = total == success + failed
              ? failed > 0
                  ? PREFIX_FAIL
                  : PREFIX_PASS
              : PREFIX_RUNS
            message = `${prefix} ${preparedSuitePath}  [${coloredCounts}]`

            return #[`${prefix} ${preparedSuitePath}`, coloredCounts]
          }
      }
    ),
    ((prepared) => {
      firsts = map(Tuple.fst, prepared)
      longest = List.reduce((biggest, input) => Math.max(biggest, String.length(input)), 0, firsts)

      map(where {
        #[start, counts] =>
          IO.putLine(`${start}${spaces(longest - String.length(start))} [${counts}]`)
      }, prepared)
    })
  )(results)
  IO.putLine("")
}


updateSuiteResult :: String -> TestResult -> a -> a
updateSuiteResult = (suitePath, result, a) => {
  pipe(
    Dictionary.update(
      where {
        SuiteResult(total, success, failed) =>
          result == Success
            ? SuiteResult(total, success + 1, failed)
            : SuiteResult(total, success, failed + 1)
      },
      suitePath
    ),
    collector.setResults
  )(collector.getResults())

  if (IS_COLOR_ENABLED) {
    do {
      IO.put(moveCursorUpCode(Dictionary.length(collector.getResults()) + 1))
      printSuiteResults(collector.getResults())
    }
  }

  return a
}


runTestSuite :: (Inspect e, Inspect f) => String -> ({} -> Wish e a) -> ({} -> Wish f b) -> List (Wish.Wish String String) -> Wish.Wish {} TestReport
runTestSuite = (suitePath, beforeAll, afterAll, testsInSuite) => pipe(
  (tests) => {
    pipe(
      Dictionary.insert(suitePath, SuiteResult(List.length(tests), 0, 0)),
      collector.setResults
    )(collector.getResults())

    return tests
  },
  map(Wish.bichain(pipe(updateSuiteResult(suitePath, Failure), failureReport, of), pipe(updateSuiteResult(suitePath, Success), successReport, of))),
  Wish.parallel,
  (testsWish) => Wish.bichain(pipe(IO.log, () => Wish.bad({})), () => testsWish, beforeAll()),
  (testsWish) => do {
    result <- testsWish
    _ <- Wish.bichain(pipe(IO.log, () => Wish.bad({})), () => of({}), afterAll())
    return of(result)
  },
  map(
    pipe(
      List.reduce(mergeReports, EMPTY_REPORT),
      where {
        TestReport(msg, total, success, failed) =>
          (total == 0 || failed > 0)
            ? TestReport(
                `${suitePath}\n${msg}${generateReportSuiteEndMessage(testsInSuite)}`,
                total,
                success,
                failed
              )
            : TestReport("", total, success, failed)
      }
    )
  )
)(testsInSuite)


runAllTestSuites :: (Inspect e, Inspect f) => List #[String, ({} -> Wish e a), ({} -> Wish f b), List (Wish.Wish String String)] -> {}
export runAllTestSuites = (testSuites) => pipe(
  map(where {
    #[path, beforeAll, afterAll, tests] =>
      runTestSuite(path, beforeAll, afterAll, tests)}
  ),
  (suites) => {
    IO.log("tchou")
    if (IS_COLOR_ENABLED) {
      printSuiteResults(collector.getResults())
    }
    return suites
  },
  Wish.parallel,
  map(List.reduce(mergeReports, EMPTY_REPORT)),
  Wish.fulfill(
    (_) => ({}),
    (report) => {
      if (!IS_COLOR_ENABLED) {
        printSuiteResults(collector.getResults())
      }
      IO.put(getMessage(report))
      IO.putLine(`Test suites: ${inspect(List.length(testSuites))}  tests: ${inspect(getTotal(report))}  passed: ${inspect(getSuccessCount(report))}  failed: ${inspect(getFailureCount(report))}`)
      if (getFailureCount(report) > 0) {
        Process.exit(1)
      }
    }
  )
)(testSuites)
