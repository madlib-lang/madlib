import {} from "Monad"
import {} from "Bifunctor"
import {} from "Alternative"
import { sortBy, length, filter, forEach } from "List"
import { Just, Nothing } from "Maybe"
import Tuple from "Tuple"
import {} from "Integer"


type TimerId = __TimerId__


/**
 * Wish represents an async computation that needs to be fulfilled. It is
 * cold and will only be run when fulfilled.
 */

export type Wish e a = Wish((e -> {}) -> (a -> {}) -> ({} -> {}))



#iftarget js

setTimeout :: ({} -> {}) -> Integer -> TimerId
setTimeout = (cb, ms) => #- global.setTimeout(cb, ms) -#

clearTimeout :: TimerId -> {}
clearTimeout = (id) => #- clearTimeout(id) -#

#elseif llvm

setTimeout :: ({} -> {}) -> Integer -> TimerId
setTimeout = extern "__setTimeout__"

clearTimeout :: TimerId -> {}
clearTimeout =  extern "__clearTimeout__"

#endif


/**
 * The functor instance of Wish provides a way to map over the value it contains.
 *
 * @since 0.0.5
 * @example
 * map((x) => x + 1, good(3)) // good(4)
 * map((x) => x + 1, bad(3))  // bad(3)
 */
instance Functor (Wish e) {
  map = (f, m) => Wish((badCB, goodCB) => where(m) {
    Wish(run) =>
      run(badCB, (x) => goodCB(f(x)))
  })
}


instance Applicative (Wish e) {
  pure = good

  ap = (mf, m) => Wish((badCB, goodCB) => where(#[mf, m]) {
    #[Wish(runMF), Wish(runM)] =>
      do {
        cancel2 = () => {}
        cancel1 = runM(
          badCB,
          (x) => {
            cancel2 = runMF(badCB, (f) => goodCB(f(x)))
          }
        )

        return () => {
          cancel1()
          cancel2()
        }
      }
  })
}


instance Monad (Wish e) {
  of = pure

  chain = (f, m) => Wish((badCB, goodCB) => {
    return where(m) {
      Wish(run) =>
        do {
          cancel = Nothing
          r1 = run(
            badCB,
            (x) => {
              r2 = where(f(x)) {
                Wish(_run) =>
                  _run(badCB, goodCB)
              }
              cancel = Just(r2)
            },
          )

          if (cancel == Nothing) do { cancel = Just(r1) }

          return () => {
            where(cancel) {
              Just(c) =>
                c()

              Nothing =>
                {}
            }
          }
        }
    }
  })
}


instance Bifunctor Wish {
  bimap = (leftF, rightF, m) => Wish((badCB, goodCB) => where(m) {
    Wish(run) => run(pipe(leftF, badCB), pipe(rightF, goodCB))
  })

  mapFirst = mapRej
  mapSecond = map
}


instance Semigroup (Wish e a) {
  assoc = (a, b) => chainRej(() => b, a)
}


/**
 * Maps over the rejected value.
 *
 * @since 0.0.5
 * @example
 * mapRej((x) => x + 1, bad(3))  // bad(4)
 * mapRej((x) => x + 1, good(3)) // good(3)
 */
mapRej :: (e -> f) -> Wish e a -> Wish f a
export mapRej = (f, m) =>
  Wish((badCB, goodCB) =>
    where(m) {
      Wish(run) =>
        run((x) => badCB(f(x)), goodCB)
    }
  )


/**
 * Chains over the rejected value.
 *
 * @since 0.0.5
 * @example
 * chainRej((x) => good(x + 1), bad(3)) // good(4)
 */
chainRej :: (e -> Wish f a) -> Wish e a -> Wish f a
export chainRej = (f, m) => Wish((badCB, goodCB) =>
  where(m) {
    Wish(run) =>
      do {
        cancel = Nothing
        r1 = run(
          (err) => {
            r2 = where(f(err)) {
              Wish(_run) =>
                _run(badCB, goodCB)
            }
            cancel = Just(r2)
          },
          (x) => { goodCB(x) }
        )

        if (cancel == Nothing) do { cancel = Just(r1) }

        return () => {
          where(cancel) {
            Just(c) =>
              c()

            Nothing =>
              {}
          }
        }
      }
  }
)


bichain :: (a -> Wish c d) -> (b -> Wish c d) -> Wish a b -> Wish c d
export bichain = (badF, goodF, m) => Wish((badCB, goodCB) =>
  where(m) {
    Wish(run) =>
      do {
        cancel = Nothing
        r1 = run(
          (err) => {
            r2 = where(badF(err)) {
              Wish(r) =>
                r(badCB, goodCB)
            }
            cancel = Just(r2)
          },
          (x) => {
            r2 = where(goodF(x)) {
              Wish(r) =>
                r(badCB, goodCB)
            }
            cancel = Just(r2)
          },
        )

        if (cancel == Nothing) do { cancel = Just(r1) }

        return () => {
          where(cancel) {
            Just(c) =>
              c()

            Nothing =>
              {}
          }
        }
      }
  }
)


good :: a -> Wish e a
export good = (a) => Wish((_, goodCB) => {
  goodCB(a)
  return () => {}
})


bad :: e -> Wish e a
export bad = (e) => Wish((badCB, _) => {
  badCB(e)
  return () => {}
})


withRej :: f -> Wish e a -> Wish f a
export withRej = (rej, wish) => mapRej(() => rej, wish)


putLine :: String -> {}
export putLine = extern "madlib__stdio__putLine"

// putLine :: String -> {}
// export putLine = #- console.log -#


chainManyN :: Integer -> (a -> Wish e b) -> List (Wish e a) -> List (Wish e b)
export chainManyN = (concurrent, f, wishes) => {
  runningWishes = 0

  runners :: List (a -> {})
  runners = []

  next :: a -> {}
  next = () => {
    where(runners) {
      [run, ...rs] =>
        do {
          runners = rs
          run()
        }

      [] =>
        {}
    }
  }

  return map(
    (wish) =>
      Wish((badCB, goodCB) =>
        where(wish) {
          Wish(run) =>
            do {
              cancel = Nothing
              r1 = run(
                (err) => {
                  runningWishes = runningWishes - 1
                  badCB(err)
                  next()
                },
                (res) => {
                  runner = () => {
                    runningWishes = runningWishes + 1
                    where(f(res)) {
                      Wish(_run) =>
                        do {
                          r2 = _run(
                            (err) => {
                              badCB(err)
                              runningWishes = runningWishes - 1
                              next()
                            },
                            (_res) => {
                              goodCB(_res)
                              runningWishes = runningWishes - 1
                              next()
                            },
                          )
                          cancel = Just(r2)
                        }
                      }
                  }
  
                  if (runningWishes < concurrent) do {
                    runner()
                    next()
                  } else do {
                    runners = runners ++ [runner]
                  }
                },
              )

              if (cancel == Nothing) do { cancel = Just(r1) }

              return () => {
                where(cancel) {
                  Just(c) =>
                    c()

                  Nothing =>
                    {}
                }
              }
            }
        }
      ),
      wishes,
  )
}


parallelN :: Integer -> List (Wish e a) -> Wish e (List a)
export parallelN = (concurrent, wishes) => Wish((badCB, goodCB) => {
  amountOfWishesToProcess = length(wishes)
  ko = false
  ok = 0
  runningWishes = 0
  wishesNotStarted = wishes
  indexOfLastStartedWish = 0

  result :: List #[Integer, a]
  result = []

  cancelationFunctions :: List #[Integer, {} -> {}]
  cancelationFunctions = []

  fork :: Integer -> List (Wish e a) -> {}
  fork = (index, ws) => where(ws) {
    [wish, ...nextWishes] =>
      do {
        wishesNotStarted = nextWishes
        runningWishes = runningWishes + 1
        indexOfLastStartedWish = indexOfLastStartedWish + 1

        where(wish) {
          Wish(run) =>
            do {
              cancel = run(
                (err) =>
                  if (!ko) do {
                    ko = true
                    forEach((cancelFunction) => Tuple.snd(cancelFunction)(), cancelationFunctions)
                    return badCB(err)
                  },
                (x) => {
                  result = [#[index, x], ...result]
                  ok = ok + 1
                  runningWishes = runningWishes - 1
                  cancelationFunctions = filter((cancelFunction) => Tuple.fst(cancelFunction) != index, cancelationFunctions)
                  return ok == amountOfWishesToProcess
                    ? pipe(
                        sortBy((a, b) => compare(Tuple.fst(a), Tuple.fst(b))),
                        map(Tuple.snd),
                        goodCB
                      )(result)
                    : fork(indexOfLastStartedWish + 1, wishesNotStarted)
                }
              )
              cancelationFunctions = [#[index, cancel], ...cancelationFunctions]
            }
        }

        if (concurrent < 0 || runningWishes < concurrent) {
          fork(indexOfLastStartedWish, wishesNotStarted)
        }
      }

    [] =>
      amountOfWishesToProcess == 0
        ? goodCB([])
        : {}
  }

  fork(0, wishes)

  return () => {
    forEach((cancelFunction) => Tuple.snd(cancelFunction)(), cancelationFunctions)
  }
})


parallel :: List (Wish e a) -> Wish e (List a)
export parallel = parallelN(-1)


discardError :: (e -> a) -> Wish e a -> Wish {} a
export discardError = (recover, wish) => Wish((_, goodCB) => where(wish) {
  Wish(run) =>
    run(pipe(recover, goodCB), goodCB)
})


fulfill :: (e -> {}) -> (a -> {}) -> Wish e a -> ({} -> {})
export fulfill = (badCB, goodCB, m) => where(m) {
  Wish(run) =>
    run(badCB, goodCB)
}


after :: Integer -> a -> Wish e a
export after = (time, a) => Wish((_, goodCB) => {
  id = setTimeout(() => { goodCB(a) }, time)

  return () => {
    putLine("-- after: CANCEL: " ++ show(time))
    clearTimeout(id)
  }
})


withTimeout :: Integer -> e -> Wish e a -> Wish e a
export withTimeout = (ms, err, wish) => Wish((badCB, goodCB) => {
  done = false
  timeoutId = __TimerId__

  return where(wish) {
    Wish(run) =>
      do {
        putLine("-- WITH TIMEOUT: START")
        cancel = run(
          (x) => {
            if (!done) do {
              clearTimeout(timeoutId)
              badCB(x)
            }
          },
          (x) => {
            if (!done) do {
              putLine("GOOD")
              done = true
              clearTimeout(timeoutId)
              goodCB(x)
            }
          }
        )

        timeoutId = setTimeout(() => {
          if (!done) do {
            putLine("-- WITH TIMEOUT: CANCEL")
            done = true
            cancel()
            badCB(err)
          }
        }, ms)

        return () => {
          done = true
          cancel()
        }
      }
  }
})
