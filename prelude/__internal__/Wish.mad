import {} from "Monad"
import {} from "Bifunctor"
import {} from "Alternative"
import { sortBy, length, reverse } from "List"
import Tuple from "Tuple"
import {} from "Integer"


type TimerId = __TimerId__

/**
 * Wish represents an async computation that needs to be fulfilled. It is
 * cold and will only be run when fulfilled.
 */

export type Wish e a = Wish((e -> {}) -> (a -> {}) -> {})



export type CancellableWish e a = CancellableWish((e -> {}) -> (a -> {}) -> ({} -> {}))

afterC :: Integer -> a -> CancellableWish e a
export afterC = (time, a) => CancellableWish((_, goodCB) => {
  id = setTimeout(() => { goodCB(a)}, time)
  return () => {
    // console.log('TRIGGERED', time)
    putLine("canceled")
    putLine(show(time))
    clearTimeout(id)
  }
})

fulfillC :: (e -> {}) -> (a -> {}) -> CancellableWish e a -> ({} -> {})
export fulfillC = (badCB, goodCB, m) => where(m) {
  CancellableWish(run) =>
    run(badCB, goodCB)
}




export chainC = (f, m) => CancellableWish((badCB, goodCB) => {
  return where(m) {
    CancellableWish(run) =>
      do {
        cancelK = run(
          (err) => {
            cancelK()
            badCB(err)
          },
          (x) => {
            cancelK = where(f(x)) {
              CancellableWish(r) =>
                r(badCB, goodCB)
            }
          },
        )

        return () => { cancelK() }
      }
  }
})

// // That one is somehow working for now

// makeSetter = (initial) => {
//   value = initial

//   set = (v) => {
//     value = v
//   }

//   get = () => value

//   return { get, set }
// }

// export chainC = (f, m) => CancellableWish((badCB, goodCB) => {
//   return where(m) {
//     CancellableWish(run) =>
//       do {
//         setter = makeSetter(() => {})

//         c = run(
//           (err) => {
//             // cancelK()
//             // c()
//             setter.get()()
//             badCB(err)
//           },
//           (x) => where(f(x)) {
//             CancellableWish(r) =>
//               do {
//                 cancelK = r(badCB, goodCB)
//                 setter.set(cancelK)
//                 // r(badCB, goodCB)
//               }
//           },
//         )

//         setter.set(c)

//         return () => { setter.get()() }
//       }
//   }
// })

badC :: e -> CancellableWish e a
export badC = (e) => CancellableWish((badCB, _) => {
  badCB(e)
  return () => {}
})


#iftarget js

setTimeout :: ({} -> {}) -> Integer -> TimerId
setTimeout = (cb, ms) => #- global.setTimeout(cb, ms) -#

clearTimeout :: TimerId -> {}
clearTimeout = (id) => #- clearTimeout(id) -#

#elseif llvm

setTimeout :: ({} -> {}) -> Integer -> TimerId
setTimeout = extern "__setTimeout__"

clearTimeout :: TimerId -> {}
clearTimeout =  extern "__clearTimeout__"

#endif

timeoutC :: Integer -> e -> CancellableWish e a -> CancellableWish e a
export timeoutC = (ms, err, wish) => CancellableWish((badCB, goodCB) => {
  done = false
  timeoutId = __TimerId__

  return where(wish) {
    CancellableWish(run) =>
      do {
        cancel = run(
          (x) => {
            if (!done) {
              badCB(x)
            }
          },
          (x) => {
            if (!done) do {
              done = true
              clearTimeout(timeoutId)
              goodCB(x)
            }
          }
        )

        timeoutId = setTimeout(() => {
          if (!done) do {
            done = true
            cancel()
            badCB(err)
          }
        }, ms)

        return cancel
      }
  }

  
})


// export type CancellableWish e a = CancellableWish((e -> {}) -> (a -> {}) -> (({} -> {}) -> {}) -> {})

// afterC :: Integer -> a -> CancellableWish e a
// export afterC = (time, a) => CancellableWish((_, goodCB, cancel) => #- {
//   const id = setTimeout(() => goodCB(a), time);
//   // console.log(stop);
//   cancel(() => {
//     console.log('TRIGGERED')
//     clearTimeout(id)
//   })
// } -#)

// makeCanceller :: a -> {
//   get :: b -> { cancel :: c -> {} },
//   set :: { cancel :: c -> {} } -> {}
// }
// makeCanceller = () => {
//   cancel = { cancel: () => {} }

//   set = (c) => {
//     cancel = c
//   }

//   get = () => cancel

//   return { get, set }
// }

// fulfillC :: (e -> {}) -> (a -> {}) -> CancellableWish e a -> ({} -> {})
// export fulfillC = (badCB, goodCB, m) => {
//   return where(m) {
//     CancellableWish(run) =>
//       do {
//         canceller = makeCanceller()
//         run(badCB, goodCB, (_c) => {
//           canceller.set({ cancel: _c })
//         })

//         return () => {
//           canceller.get().cancel()
//         }
//       }
//   }
// }

// export chainC = (f, m) => CancellableWish((badCB, goodCB, cancel) => {
//   return where(m) {
//     CancellableWish(run) =>
//       do {
//         run(
//           (err) => {
//             badCB(err)
//           },
//           (x) => where(f(x)) {
//             CancellableWish(r) =>
//               do {
//                 r(badCB, goodCB, cancel)
//               }
//           },
//           cancel,
//         )
//       }
//   }
// })

/**
 * The functor instance of Wish provides a way to map over the value it contains.
 *
 * @since 0.0.5
 * @example
 * map((x) => x + 1, good(3)) // good(4)
 * map((x) => x + 1, bad(3))  // bad(3)
 */
instance Functor (Wish e) {
  map = (f, m) => Wish((badCB, goodCB) => where(m) {
    Wish(run) =>
      run(badCB, (x) => (goodCB(f(x))))
  })
}


instance Applicative (Wish e) {
  pure = (a) => Wish((_, goodCB) => goodCB(a))

  ap = (mf, m) => Wish((badCB, goodCB) => where(#[mf, m]) {
    #[Wish(runMF), Wish(runM)] =>
      runM(
        badCB,
        (x) => runMF(
          badCB,
          (f) => goodCB(f(x))
        )
      )
    }
  )
}


instance Monad (Wish e) {
  of = pure

  chain = (f, m) => Wish((badCB, goodCB) => where(m) {
    Wish(run) => run(badCB, (x) => where(f(x)) { Wish(r) => r(badCB, goodCB) })
  })
}


instance Bifunctor Wish {
  bimap = (leftF, rightF, m) => Wish((badCB, goodCB) => where(m) {
    Wish(run) => run(pipe(leftF, badCB), pipe(rightF, goodCB))
  })

  mapFirst = mapRej
  mapSecond = map
}


instance Semigroup (Wish e a) {
  assoc = (a, b) => chainRej(() => b, a)
}


/**
 * Maps over the rejected value.
 *
 * @since 0.0.5
 * @example
 * mapRej((x) => x + 1, bad(3))  // bad(4)
 * mapRej((x) => x + 1, good(3)) // good(3)
 */
mapRej :: (e -> f) -> Wish e a -> Wish f a
export mapRej = (f, m) =>
  Wish((badCB, goodCB) =>
    where(m) { Wish(run) => run((x) => (badCB(f(x))), goodCB) }
  )


/**
 * Chains over the rejected value.
 *
 * @since 0.0.5
 * @example
 * chainRej((x) => good(x + 1), bad(3)) // good(4)
 */
chainRej :: (e -> Wish f a) -> Wish e a -> Wish f a
export chainRej = (f, m) => Wish((badCB, goodCB) =>
  where(m) {
    Wish(run) => run((x) => (
      where(f(x)) {
        Wish(r) => r(badCB, goodCB)
      }
    ), goodCB)
  }
)


bichain :: (a -> Wish c d) -> (b -> Wish c d) -> Wish a b -> Wish c d
export bichain = (badF, goodF, m) => Wish((badCB, goodCB) =>
  where(m) {
    Wish(run) =>
      run(
        (x) => where(badF(x)) { Wish(r) => r(badCB, goodCB) },
        (x) => where(goodF(x)) { Wish(r) => r(badCB, goodCB) }
      )
  }
)


good :: a -> Wish e a
export good = (a) => Wish((_, goodCB) => goodCB(a))


bad :: e -> Wish e a
export bad = (e) => Wish((badCB, _) => badCB(e))


withRej :: f -> Wish e a -> Wish f a
export withRej = (rej, wish) => mapRej(() => rej, wish)


putLine :: String -> {}
export putLine = extern "madlib__stdio__putLine"

// putLine :: String -> {}
// putLine = #- console.log -#

chainManyN :: Integer -> (a -> Wish e b) -> List (Wish e a) -> List (Wish e b)
export chainManyN = (concurrent, f, wishes) => {
  runningWishes = 0

  runners :: List (a -> {})
  runners = []

  next :: a -> {}
  next = () => {
    where(runners) {
      [run, ...rs] =>
        do {
          runners = rs
          run()
        }

      [] =>
        {}
    }
  }

  return map(
    (wish) =>
      Wish((badCB, goodCB) =>
        where(wish) {
          Wish(run) =>
            run(
              (err) => {
                runningWishes = runningWishes - 1
                badCB(err)
                next()
              },
              (res) => {
                runner = () => {
                  // putLine("runner")
                  runningWishes = runningWishes + 1
                  where(f(res)) {
                    Wish(r) =>
                      r(
                        (err) => {
                          badCB(err)
                          runningWishes = runningWishes - 1
                          next()
                        },
                        (_res) => {
                          goodCB(_res)
                          runningWishes = runningWishes - 1
                          next()
                        },
                      )
                  }
                }

                if (runningWishes < concurrent) do {
                  runner()
                  next()
                } else do {
                  runners = [runner, ...runners]
                }
              },
            )
        }
      ),
      reverse(wishes),
  )
}


parallelN :: Integer -> List (Wish e a) -> Wish e (List a)
export parallelN = (concurrent, wishes) => Wish((badCB, goodCB) => {
  amountOfWishesToProcess = length(wishes)
  ko = false
  ok = 0
  runningWishes = 0
  wishesNotStarted = wishes
  indexOfLastStartedWish = 0

  result :: List #[Integer, a]
  result = []

  fork :: Integer -> List (Wish e a) -> {}
  fork = (index, ws) => where(ws) {
    [wish, ...nextWishes] =>
      do {
        wishesNotStarted = nextWishes
        runningWishes = runningWishes + 1
        indexOfLastStartedWish = indexOfLastStartedWish + 1

        where(wish) {
          Wish(run) =>
            run(
              (err) =>
                if (!ko) do {
                  ko = true
                  return badCB(err)
                },
              (x) => {
                result = [#[index, x], ...result]
                ok = ok + 1
                runningWishes = runningWishes - 1
                return ok == amountOfWishesToProcess
                  ? pipe(
                      sortBy((a, b) => compare(Tuple.fst(a), Tuple.fst(b))),
                      map(Tuple.snd),
                      goodCB
                    )(result)
                  : fork(indexOfLastStartedWish + 1, wishesNotStarted)
              }
            )
        }

        if (concurrent < 0 || runningWishes < concurrent) {
          fork(indexOfLastStartedWish, wishesNotStarted)
        }
      }

    [] =>
      amountOfWishesToProcess == 0
        ? goodCB([])
        : {}
  }

  return fork(0, wishes)
})


parallel :: List (Wish e a) -> Wish e (List a)
export parallel = parallelN(-1)


discardError :: (e -> a) -> Wish e a -> Wish {} a
export discardError = (recover, wish) => Wish((_, goodCB) => where(wish) {
  Wish(run) =>
    run(pipe(recover, goodCB), goodCB)
})


#iftarget js

fulfill :: (e -> {}) -> (a -> {}) -> Wish e a -> {}
export fulfill = (badCB, goodCB, m) => {
  where(m) {
    Wish(run) => run(badCB, goodCB)
    // Wish(run) => #- setTimeout(() => run(badCB)(goodCB), 0); -#
  }

  return {}
}


after :: Integer -> a -> Wish e a
export after = (time, a) => Wish((_, goodCB) => #- {
  setTimeout(() => goodCB(a), time);
} -#)

#elseif llvm

fulfill :: (e -> {}) -> (a -> {}) -> Wish e a -> {}
export fulfill = (badCB, goodCB, m) => {
  where(m) {
    Wish(run) =>
      run(badCB, goodCB)
      // setTimeout(() => run(badCB, goodCB), 0)
  }

  return {}
}


// setTimeout :: ({} -> {}) -> Integer -> TimerId
// setTimeout = extern "__setTimeout__"


after :: Integer -> a -> Wish e a
export after = (time, a) => Wish((_, goodCB) => {
  setTimeout(() => goodCB(a), time)}
)

#endif
