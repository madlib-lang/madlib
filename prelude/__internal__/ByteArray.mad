import type { Maybe } from "Maybe"

import { Just, Nothing } from "Maybe"



/**
 * ByteArray is a specialized array type that only contains bytes. It has a
 * fast path to convert to and from string which makes it practical when
 * dealing with raw bytes representing text data.
 *
 * Note: Most IO apis such as File or Http provide both functions that work with
 * String and functions that work with ByteArray.
 *
 */

// TODO: Add filter, ap and chain

#iftarget llvm

init :: Integer -> ByteArray
export init = extern "madlib__bytearray__initWithCapacity"


/**
 * Return the byte at a given index, it crashes if the index is out of
 * the bounds of the array.
 * @since 0.23.0
 * @example
 * at(1, fromList([1, 2, 3])) // 2
 * at(3, fromList([1, 2, 3])) // crash, it exits with error
 */
unsafeAt :: Integer -> ByteArray -> Byte
export unsafeAt = extern "madlib__bytearray__unsafeAt"


/**
 * Creates a byte array from a list of bytes.
 *
 * @since 0.11.0
 * @example
 * fromList([90, 91, 92])
 */
fromList :: List Byte -> ByteArray
export fromList = extern "madlib__bytearray__fromList"


/**
 * Converts a byte array to a list of bytes.
 *
 * @since 0.11.0
 * @example
 * toList(fromString("abc"))
 */
toList :: ByteArray -> List Byte
export toList = extern "madlib__bytearray__toList"


/**
 * Creates a byte array from a string.
 *
 * @since 0.11.0
 * @example
 * fromString("abc")
 */
fromString :: String -> ByteArray
export fromString = extern "madlib__bytearray__fromString"


/**
 * Converts a byte array to a string
 *
 * @since 0.11.0
 * @example
 * toString(fromList([90, 91, 92]))
 */
toString :: ByteArray -> String
export toString = extern "madlib__bytearray__toString"


/**
 * Returns the length of a ByteArray.
 *
 * @since 0.7.0
 * @example
 * length(fromString("abc")) // 3
 */
length :: ByteArray -> Integer
export length = extern "madlib__bytearray__length"


/**
 * Concatenates two byte arrays
 *
 * @since 0.11.0
 * @example
 * concat(fromString("123"), fromString("456")) // fromString("123456")
 */
concat :: ByteArray -> ByteArray -> ByteArray
export concat = extern "madlib__bytearray__concat"


/**
 * Concatenates two byte arrays with mutation, the second ByteArray
 * is added to the end of the first one.
 *
 * @since 0.23.0
 * @example
 * concat(fromString("123"), fromString("456")) // fromString("123456")
 */
weld :: ByteArray -> ByteArray -> ByteArray
export weld = extern "madlib__bytearray__concatWithMutation"


/**
 * Maps the bytes of a byte array, applying the given function to each byte.
 *
 * @since 0.11.0
 * @example
 * mapBytes(substract(10), fromString("pqr"))
 */
mapBytes :: (Byte -> Byte) -> ByteArray -> ByteArray
export mapBytes = extern "madlib__bytearray__map"


/**
 * Reduces a byte array to a value, given a reducer function, an initial value, and a byte array.
 *
 * @since 0.11.0
 * @example
 * reduce(add, 0, fromList([1, 2, 3])) // 6
 */
reduce :: (a -> Byte -> a) -> a -> ByteArray -> a
export reduce = extern "madlib__bytearray__reduce"

#elseif js

init :: Integer -> ByteArray
export init = () => #- new Uint8Array() -#


/**
 * Return the byte at a given index, it crashes if the index is out of
 * the bounds of the array.
 * @since 0.23.0
 * @example
 * at(1, fromList([1, 2, 3])) // 2
 * at(3, fromList([1, 2, 3])) // crash, it exits with error
 */
unsafeAt :: Integer -> ByteArray -> Byte
export unsafeAt = (index, byteArray) => #- {
  if (index >= byteArray.length) {
    throw `Array out of bounds access\\nYou accessed the index '${index}' but the array currently has length '${byteArray.length}'`
  }
  return byteArray[index]
} -#


/**
 * Converts a byte array to a string
 *
 * @since 0.11.0
 * @example
 * toString(fromList([90, 91, 92]))
 */
toString :: ByteArray -> String
export toString = (byteArray) => #- { return new TextDecoder().decode(byteArray) } -#


/**
 * Creates a byte array from a string.
 *
 * @since 0.11.0
 * @example
 * fromString("abc")
 */
fromString :: String -> ByteArray
export fromString = (str) => #- { return new TextEncoder().encode(str) } -#


/**
 * Converts a byte array to a list of bytes.
 *
 * @since 0.11.0
 * @example
 * toList(fromString("abc"))
 */
toList :: ByteArray -> List Byte
export toList = (byteArray) => #- {
  if (byteArray.length === 0) {
    return null
  }

  let current = {}
  let result = current
  byteArray.forEach((byte) => {
    current = current.n = { v: byte, n: null }
  })
  return result.n
} -#


/**
 * Creates a byte array from a list of bytes.
 *
 * @since 0.11.0
 * @example
 * fromList([90, 91, 92])
 */
fromList :: List Byte -> ByteArray
export fromList = (bytes) => #- {
  let bytesArray = []
  while (bytes !== null) {
    bytesArray.push(bytes.v)
    bytes = bytes.n
  }
  return Uint8Array.from(bytesArray)
} -#


/**
 * Concatenates two byte arrays
 *
 * @since 0.11.0
 * @example
 * concat(fromString("123"), fromString("456")) // fromString("123456")
 */
concat :: ByteArray -> ByteArray -> ByteArray
export concat = (byteArray1, byteArray2) => #- {
  const result = new Uint8Array(byteArray1.length + byteArray2.length);
  result.set(byteArray1);
  result.set(byteArray2, byteArray1.length);
  return result;
} -#


/**
 * Concatenates two byte arrays
 *
 * @since 0.11.0
 * @example
 * concat(fromString("123"), fromString("456")) // fromString("123456")
 */
weld :: ByteArray -> ByteArray -> ByteArray
export weld = (byteArray1, byteArray2) => #- {
  const result = new Uint8Array(byteArray1.length + byteArray2.length);
  result.set(byteArray1);
  result.set(byteArray2, byteArray1.length);
  return result;
} -#


/**
 * Maps the bytes of a byte array, applying the given function to each byte.
 *
 * @since 0.11.0
 * @example
 * mapBytes(substract(10), fromString("pqr"))
 */
mapBytes :: (Byte -> Byte) -> ByteArray -> ByteArray
export mapBytes = (f, byteArray) => #- { return byteArray.map(f) } -#


/**
 * Reduces a byte array to a value, given a reducer function, an initial value, and a byte array.
 *
 * @since 0.11.0
 * @example
 * reduce(add, 0, fromList([1, 2, 3])) // 6
 */
reduce :: (a -> Byte -> a) -> a -> ByteArray -> a
export reduce = (
  f,
  initialValue,
  byteArray
) => #- { return byteArray.reduce((a, b) => f(a)(b), initialValue) } -#


/**
 * Returns the length of a ByteArray.
 *
 * @since 0.7.0
 * @example
 * length(fromString("abc")) // 3
 */
length :: ByteArray -> Integer
export length = (byteArray) => #- { return byteArray.length } -#

#endif


/**
 * The empty byte array
 *
 * @since 0.11.0
 * @example
 * empty == empty // true
 */
empty :: {} -> ByteArray
export empty = () => fromList([])


at :: Integer -> ByteArray -> Maybe Byte
export at = (index, arr) => index > 0 && index < length(arr) ? Just(unsafeAt(index, arr)) : Nothing
