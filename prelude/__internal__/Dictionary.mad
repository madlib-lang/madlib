import type { Dictionary, NodeColor } from "__BUILTINS__"
import { Empty, Node, BlackNode, RedNode } from "__BUILTINS__"
import __BUILTINS__ from "__BUILTINS__"
import type { Maybe } from "Maybe"
import { Nothing, Just } from "Maybe"

import List from "List"


/**
 * Dictionary represents a key - value data structure.
 * It is implemented as a red black tree
 */


instance Functor (Dictionary k) {
  map = (f, dict) => where(dict) {
    Empty =>
      Empty

    Node(c, k, v, left, right) =>
      Node(c, k, f(v), map(f, left), map(f, right))
  }
}


mapM :: Monad m => (a -> m b) -> Dictionary k a -> m (Dictionary k b)
export mapM = (f, dict) => where(dict) {
  Empty =>
    pure(Empty)

  Node(c, k, v, left, right) =>
    do {
      _v <- f(v)
      _left <- mapM(f, left)
      _right <- mapM(f, right)

      return of(Node(c, k, _v, _left, _right))
    }
}


mapWithKey :: (a -> b -> c) -> Dictionary a b -> Dictionary a c
export mapWithKey = (f, dict) => where(dict) {
  Empty =>
    Empty

  Node(c, k, v, left, right) =>
    Node(c, k, f(k, v), mapWithKey(f, left), mapWithKey(f, right))
}


filter :: Comparable k => (v -> Boolean) -> Dictionary k v -> Dictionary k v
export filter = (f, dict) =>
  reduceLeft((k, v, d) => f(v) ? insert(k, v, d) : d, empty, dict)


filterWithKey :: Comparable k => (k -> v -> Boolean) -> Dictionary k v -> Dictionary k v
export filterWithKey = (f, dict) =>
  reduceLeft((k, v, d) => f(k, v) ? insert(k, v, d) : d, empty, dict)


fromList :: Comparable k => List (#[k, v]) -> Dictionary k v
export fromList = __BUILTINS__.dictFromList


toList :: Dictionary k v -> List #[k, v]
export toList = __BUILTINS__.dictToList


reduceLeft :: (k -> v -> a -> a) -> a -> Dictionary k v -> a
export reduceLeft = (f, acc, dict) => where(dict) {
  Empty =>
    acc

  Node(_, k, v, left, right) =>
    reduceLeft(f, f(k, v, reduceLeft(f, acc, left)), right)
}


reduce :: (k -> v -> a -> a) -> a -> Dictionary k v -> a
export reduce = reduceLeft


reduceRight :: (k -> v -> a -> a) -> a -> Dictionary k v -> a
export reduceRight = __BUILTINS__.dictReduceRight


get :: Comparable k => k -> Dictionary k v -> Maybe v
export get = (k, dict) => where(dict) {
  Empty =>
    Nothing

  Node(_, _k, _v, left, right) =>
    if (k == _k) {
      Just(_v)
    } else if (k > _k) {
      get(k, right)
    } else {
      get(k, left)
    }
}


includes :: Comparable k => k -> Dictionary k v -> Boolean
export includes = (k, dict) => where(get(k, dict)) {
  Just(_) =>
    true

  Nothing =>
    false
}


insert :: Comparable k => k -> v -> Dictionary k v -> Dictionary k v
export insert = __BUILTINS__.dictInsert


empty :: Dictionary k v
export empty = Empty


keys :: Dictionary a b -> List a
export keys = (dict) => reduceRight((k, _, ks) => [k, ...ks], [], dict)


values :: Dictionary a b -> List b
export values = (dict) => reduceRight((_, v, vs) => [v, ...vs], [], dict)


length :: Dictionary a b -> Integer
export length = (dict) => where(dict) {
  Empty =>
    0

  Node(_, _, _, left, right) =>
    1 + length(left) + length(right)
}


singleton :: k -> v -> Dictionary k v
export singleton = (k, v) => Node(BlackNode, k, v, Empty, Empty)


merge :: Comparable k => Dictionary k v -> Dictionary k v -> Dictionary k v
export merge = (a, b) => reduceLeft((k, v, dict) => insert(k, v, dict), a, b)


update :: Comparable k => (v -> v) -> k -> Dictionary k v -> Dictionary k v
export update = (f, k, dict) => where(get(k, dict)) {
  Just(v) =>
    __BUILTINS__.dictInsert(k, f(v), dict)

  Nothing =>
    dict
}


remove :: Comparable k => k -> Dictionary k v -> Dictionary k v
export remove = (key, dict) => where(removeHelp(key, dict)) {
  Node(RedNode, k, v, left, right) =>
    Node(BlackNode, k, v, left, right)

  or =>
    or
}


removeHelp :: Comparable k => k -> Dictionary k v -> Dictionary k v
removeHelp = (targetKey, dict) => where(dict) {
  Empty =>
    Empty

  Node(color, key, value, left, right) =>
    if (targetKey < key) {
      where(left) {
        Node(BlackNode, _, _, lLeft, _) =>
          where(lLeft) {
            Node(RedNode, _, _, _, _) =>
              Node(color, key, value, removeHelp(targetKey, left), right)

            _ =>
              where(moveRedLeft(dict)) {
                Node(nColor, nKey, nValue, nLeft, nRight) =>
                  __BUILTINS__.balanceDict(nColor, nKey, nValue, removeHelp(targetKey, nLeft), nRight)

                Empty =>
                  Empty
              }
          }

        _ =>
          Node(color, key, value, removeHelp(targetKey, left), right)
      }
    } else {
      removeHelpEQGT(targetKey, removeHelpPrepEQGT(dict, color, key, value, left, right))
    }
}


removeHelpPrepEQGT :: Comparable k => Dictionary k v -> NodeColor -> k -> v -> Dictionary k v -> Dictionary k v -> Dictionary k v
removeHelpPrepEQGT = (dict, color, key, value, left, right) => where(left) {
  Node(RedNode, lK, lV, lLeft, lRight) =>
    Node(color, lK, lV, lLeft, Node(RedNode, key, value, lRight, right))

  _ =>
    where(right) {
      Node(BlackNode, _, _, Node(BlackNode, _, _, _, _), _) =>
        moveRedRight(dict)

      Node(BlackNode, _, _, Empty, _) =>
        moveRedRight(dict)

      _ =>
        dict
    }
}


removeHelpEQGT :: Comparable k => k -> Dictionary k v -> Dictionary k v
removeHelpEQGT = (targetKey, dict) => where(dict) {
  Node(c, k, v, left, right) =>
    if (targetKey == k) {
      where(getMin(right)) {
        Node(_, minKey, minValue, _, _) =>
          __BUILTINS__.balanceDict(c, minKey, minValue, left, removeMin(right))

        Empty =>
          Empty
      }
    } else {
      __BUILTINS__.balanceDict(c, k, v, left, removeHelp(targetKey, right))
    }

  Empty =>
    Empty
}


getMin :: Dictionary k v -> Dictionary k v
getMin = (dict) => where(dict) {
  Node(_, _, _, left, _) =>
    where(left) {
      Node(_, _, _, _, _) =>
        getMin(left)

      _ =>
        dict
    }

  _ =>
    dict
}


removeMin :: Dictionary k v -> Dictionary k v
removeMin = (dict) => where(dict) {
  Node(c, k, v, Node(lC, lK, lV, lLeft, lRight), right) =>
    where(lC) {
      BlackNode =>
        where(lLeft) {
          Node(RedNode, _, _, _, _) =>
            Node(c, k, v, removeMin(Node(lC, lK, lV, lLeft, lRight)), right)

          _ =>
            where(moveRedLeft(dict)) {
              Node(nC, nK, nV, nLeft, nRight) =>
                __BUILTINS__.balanceDict(nC, nK, nV, removeMin(nLeft), nRight)

              Empty =>
                Empty
            }
        }

      _ =>
        Node(c, k, v, removeMin(Node(lC, lK, lV, lLeft, lRight)), right)
    }

  _ =>
    Empty
}


moveRedLeft :: Dictionary k v -> Dictionary k v
moveRedLeft = (dict) => where(dict) {
  Node(c, k, v, Node(lC, lK, lV, lLeft, lRight), Node(rC, rK, rV, Node(RedNode, rlK, rlV, rlL, rlR), rRight)) =>
    Node(RedNode, rlK, rlV, Node(BlackNode, k, v, Node(RedNode, lK, lV, lLeft, lRight), rlL), Node(BlackNode, rK, rV, rlR, rRight))

  Node(c, k, v, Node(lC, lK, lV, lLeft, lRight), Node(rC, rK, rV, rLeft, rRight)) =>
    where(c) {
      BlackNode =>
        Node(BlackNode, k, v, Node(RedNode, lK, lV, lLeft, lRight), Node(RedNode, rK, rV, rLeft, rRight))

      RedNode =>
        Node(BlackNode, k, v, Node(RedNode, lK, lV, lLeft, lRight), Node(RedNode, rK, rV, rLeft, rRight))
    }

  _ =>
    dict
}


moveRedRight :: Dictionary k v -> Dictionary k v
moveRedRight = (dict) => where(dict) {
  Node(c, k, v, Node(lC, lK, lV, Node(RedNode, llK, llV, llLeft, llRight), lRight), Node(rC, rK, rV, rLeft, rRight)) =>
    Node(RedNode, lK, lV, Node(BlackNode, llK, llV, llLeft, llRight), Node(BlackNode, k, v, lRight, Node(RedNode, rK, rV, rLeft, rRight)))

  Node(c, k, v, Node(lC, lK, lV, lLeft, lRight), Node(rC, rK, rV, rLeft, rRight)) =>
    where(c) {
      BlackNode =>
        Node(BlackNode, k, v, Node(RedNode, lK, lV, lLeft, lRight), Node(RedNode, rK, rV, rLeft, rRight))

      RedNode =>
        Node(BlackNode, k, v, Node(RedNode, lK, lV, lLeft, lRight), Node(RedNode, rK, rV, rLeft, rRight))
    }

  _ =>
    dict
}
