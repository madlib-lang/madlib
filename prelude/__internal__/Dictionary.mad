import type { Maybe } from "Maybe"

import {} from "Compare"
import List from "List"
import Tuple from "Tuple"

/**
 * Dictionary represents a key - value data structure.
 *
 * @since 0.0.5
 */


#iftarget js // Dictionary

Dictionary :: List #[k, v] -> Dictionary k v
Dictionary = (items) => #- ({
  __constructor: "Dictionary",
  __args: [items],
}) -#

#elseif llvm

Dictionary :: List #[k, v] -> Dictionary k v
Dictionary = extern "madlib__dictionary__typeConstructor"

#endif

#iftarget js // fromList

/**
 * Creates a Dictionary from a list of <key, value> tuples
 *
 * @since 0.0.5
 * @example
 * fromList([#["one", 2], #["two", 2]])
 * fromList([#["a", 2], #["b", 2], #["c", 3]])
 */
fromList :: Comparable k =>  List (#[k, v]) -> Dictionary k v
export fromList = pipe(
  List.uniqueBy((a, b) => Tuple.fst(a) == Tuple.fst(b)),
  Dictionary
)

#endif

/**
 * The empty Dictionary
 *
 * @since 0.0.5
 */
empty :: Dictionary k v
export empty = Dictionary([])

#iftarget js // insert

#-
const insertFFI = comparableDict => key => value => dictionary => {
  let inserted = false
  let i = 0
  let resultItems = Array(dictionary.__args.length)

  for (const [itemIndex, item] of dictionary.__args[0].entries()) {
    let mustInsert = dictionary.__args[0][itemIndex + 1] !== undefined
      ? comparableDict.compare()(key)(dictionary.__args[0][itemIndex + 1][0]) == -1
      : true

    const [currentKey, currentValue] = item
    if (comparableDict.compare()(key)(currentKey) == 0) {
      resultItems[i] = [currentKey, value]
      inserted = true
    } else if (comparableDict.compare()(key)(currentKey) == 1 && !inserted && mustInsert) {
      resultItems[i] = item
      i = i + 1
      resultItems[i] = [key, value]
      inserted = true
    } else {
      resultItems[i] = item
    }

    i = i + 1
  }

  if (!inserted) {
    resultItems[i] = [key, value]
  }

  return Dictionary(resultItems)
}
-#

/**
 * Inserts a value into the Dictionary at a given key.
 * However, if the key already exists, it updates the value at that key.
 *
 * @since 0.0.5
 * @example
 * insert(1, 2, empty)              // fromList([#[1, 2]])
 * insert(1, 7, fromList([#[1, 2]])) // fromList([#[1, 7]])
 */
insert :: Comparable k => k -> v -> Dictionary k v -> Dictionary k v
export insert = extern "insertFFI"

#elseif llvm

insert :: Comparable k => k -> v -> Dictionary k v -> Dictionary k v
export insert = extern "madlib__dictionary__insert"

#endif

#iftarget js // get

/**
 * Get a value from a Dictionary given a key.
 *
 * @since 0.0.5
 * @example
 * get("john", fromList([#["john", { age: 32 }]])) // Just({ age: 32 })
 * get("paul", fromList([#["john", { age: 32 }]])) // Nothing
 */
get :: Comparable k => k -> Dictionary k v -> Maybe v
export get = (k) => where {
  Dictionary(items) => pipe(
    List.find((item) => where(item) {
      #[kk, _] => k == kk
    }),
    map(Tuple.snd)
  )(items)
}

#endif


#iftarget js // merge

/**
 * Combine two Dictionaries together.
 *
 * @since 0.0.5
 */
merge :: Comparable k => Dictionary k v -> Dictionary k v -> Dictionary k v
export merge = (a, b) => where(#[a, b]) {
  #[Dictionary(itemsA), Dictionary(itemsB)] => List.concat(itemsA, itemsB) |> fromList
}

#endif

/**
 * Enumerate the number of keys in a Dictionary
 *
 * @since 0.0.5
 * @example
 * len(fromList([#["Sidney", 3], #["New York", 18], #["London", 2]])) // 3
 */
len :: Dictionary k v -> Integer
export len = (dictionary) => where(dictionary) {
  Dictionary(items) =>
    List.len(items)
}


toList :: Dictionary k v -> List #[k, v]
export toList = (dict) => where(dict) {
  Dictionary(items) =>
    items
}


/**
 * Map over a Dictionary with a function that takes the value and transforms it.
 *
 * @since 0.0.5
 * @example
 * map((x) => x / 2, fromList([#["Sidney", 3], #["New York", 18], #["London", 2]]))
 * // fromList([#["Sidney", 1.5], #["New York", 9], #["London", 1]])
 */
instance Functor (Dictionary k) {
  map = (fn) => where {
    Dictionary(items) =>
      pipe(
        map((i) => #[Tuple.fst(i), fn(Tuple.snd(i))]),
        Dictionary
      )(items)
  }
}


/**
 * Map over a Dictionary with a function that takes the key and value and returns the new value. 
 *
 * @since 0.0.5
 * @example
 * mapWithKey(
 *   (city, x) => city == "Sidney" ? 9 : x / 2,
 *   fromList([#["Sidney", 3], #["New York", 18], #["London", 2]])
 * )
 * // fromList([#["Sidney", 9], #["New York", 9], #["London", 1]])
 */
mapWithKey :: (k -> v -> w) -> Dictionary k v -> Dictionary k w
export mapWithKey = (fn) => where {
  Dictionary(items) =>
    pipe(
      map((i) => #[Tuple.fst(i), fn(Tuple.fst(i), Tuple.snd(i))]),
      Dictionary
    )(items)
}


/**
 * List all keys in a Dictionary
 *
 * @since 0.0.5
 * @example
 * keys(fromList([#[true, "Go for it"], #[false, "NOGO"]])) // [true, false]
 */
keys :: Dictionary k v -> List k
export keys = (m) => where(m) {
  Dictionary(items) =>
    map(Tuple.fst, items)
}


/**
 * List all values in a Dictionary
 *
 * @since 0.0.5
 * @example
 * values(fromList([#[true, "Go for it"], #[false, "NOGO"]])) // ["Go for it", "NOGO"]
 */
values :: Dictionary k v -> List v
export values = (m) => where(m) {
  Dictionary(items) =>
   map(Tuple.snd, items)
}
