import File from "File"
import { UnknownError } from "IOError"
import { fulfill, mapRej } from "Wish"
import Dictionary from "Dictionary"
import List from "List"
import Tuple from "Tuple"
import { Just, Nothing } from "Maybe"
import { EQUAL } from "Compare"
// needed as an import is generated in Canonicalize.Coverage
import Process from "Process"


alias HitCounter = { increment :: {} -> {}, read :: {} -> Integer }

makeHitCounter :: Integer -> HitCounter
makeHitCounter = (initial) => {
  value = initial

  read :: {} -> Integer
  read = () => value

  increment :: {} -> {}
  increment = () => {
    value = value + 1
  }

  return { increment, read }
}

type CoverableLine = CoverableLine(Integer)
type CoverableFunction = CoverableFunction(Integer, String)
type CoverableBranch = CoverableBranch(Integer, Integer, Integer)

alias CoverageData = {
  coverableLines :: Dictionary CoverableLine HitCounter,
  coverableFunctions :: Dictionary CoverableFunction HitCounter,
  coverableBranches :: Dictionary CoverableBranch HitCounter,
}


// ---------- LCOV ------------

// TN:<test name> usually empty
// SF:<absolute path to the source file>
// FN:<line number of function start>,<function name>
// FNDA:<execution count>,<function name>
// FNF:<number of functions found>
// FNH:<number of function hit>
// BRDA:<line number>,<block number>,<branch number>,<taken>
// BRF:<number of branches found>
// BRH:<number of branches hit>
// DA:<line number>,<execution count>
// LH:<number of lines with a non-zero execution count>
// LF:<number of instrumented lines>
// end_of_record

type LcovLine
  = TN(String)
  | SF(String)
  | FN(Integer, String)
  | FNDA(Integer, String)
  | FNF(Integer)
  | FNH(Integer)
  | DA(Integer, Integer)
  | LF(Integer)
  | LH(Integer)
  | BRF(Integer)
  | BRH(Integer)
  | BRDA(Integer, Integer, Integer, Integer)


alias LcovSection = {
  tn :: LcovLine,
  sf :: LcovLine,
  fns :: List LcovLine,
  fndas :: List LcovLine,
  fnf :: LcovLine,
  fnh :: LcovLine,
  das :: List LcovLine,
  lf :: LcovLine,
  lh :: LcovLine,
  brf :: LcovLine,
  brh :: LcovLine,
  brdas :: List LcovLine,
}

alias LcovInfo = List LcovSection

emptySection :: LcovSection
emptySection = {
  tn: TN(""),
  sf: SF(""),
  fns: [],
  fndas: [],
  fnf: FNF(0),
  fnh: FNH(0),
  das: [],
  lf: LF(0),
  lh: LH(0),
  brf: BRF(0),
  brh: BRH(0),
  brdas: [],
}

stringifyLine :: LcovLine -> String
stringifyLine = (line) => where(line){
  TN(arg) =>
    "TN:" ++ arg ++ "\n"

  SF(arg) =>
    "SF:" ++ arg ++ "\n"

  FN(l, name) =>
    "FN:" ++ inspect(l) ++ "," ++ name ++ "\n"

  FNDA(count, name) =>
    "FNDA:" ++ inspect(count) ++ "," ++ name ++ "\n"

  FNF(count) =>
    "FNF:" ++ inspect(count) ++ "\n"

  FNH(count) =>
    "FNH:" ++ inspect(count) ++ "\n"

  DA(l, count) =>
    "DA:" ++ inspect(l) ++ "," ++ inspect(count) ++ "\n"

  LF(count) =>
    "LF:" ++ inspect(count) ++ "\n"

  LH(count) =>
    "LH:" ++ inspect(count) ++ "\n"

  BRF(count) =>
    "BRF:" ++ inspect(count) ++ "\n"

  BRH(count) =>
    "BRH:" ++ inspect(count) ++ "\n"

  BRDA(l, blockNumber, branchNumber, count) =>
    `BRDA:${inspect(l)},${inspect(blockNumber)},${inspect(branchNumber)},${inspect(count)}\n`
}

stringifySection :: LcovSection -> String
stringifySection = (section) =>
 stringifyLine(section.tn)
 ++ stringifyLine(section.sf)
 ++ List.reduceLeft((fns, line) => fns ++ stringifyLine(line), "", section.fns)
 ++ List.reduceLeft((fndas, line) => fndas ++ stringifyLine(line), "", section.fndas)
 ++ stringifyLine(section.fnf)
 ++ stringifyLine(section.fnh)
 ++ List.reduceLeft((das, line) => das ++ stringifyLine(line), "", section.das)
 ++ stringifyLine(section.lf)
 ++ stringifyLine(section.lh)
 ++ stringifyLine(section.brf)
 ++ stringifyLine(section.brh)
 ++ List.reduceLeft((brdas, line) => brdas ++ stringifyLine(line), "", section.brdas)
 ++ "end_of_record\n"

stringify :: LcovInfo -> String
export stringify = (lcov) => List.reduceLeft((r, section) => r ++ stringifySection(section), "", lcov)


// currently not used, possibly we want to move this to List but because of
// cyclical imports we need to find a solution for private / public modules
// in prelude
groupOn :: Comparable b => (a -> b) -> List a -> List (List a)
groupOn = (f) => {
  unpack = pipe(Dictionary.toList, map(Tuple.snd))
  fld = (m, a) => where(Dictionary.get(f(a), m)) {
    Nothing =>
      Dictionary.insert(f(a), [a], m)

    Just(as) =>
      Dictionary.insert(f(a), [a, ...as], m)
  }

  return pipe(List.reduceLeft(fld, Dictionary.empty), unpack)
}


instance Comparable CoverableLine {
  compare = (a, b) => where(#[a, b]) {
    #[CoverableLine(la), CoverableLine(lb)] =>
      compare(la, lb)
  }
}

instance Comparable CoverableFunction {
  compare = (a, b) => where(#[a, b]) {
    #[CoverableFunction(la, na), CoverableFunction(lb, nb)] =>
      do {
        lineComparison = compare(la, lb)

        return lineComparison == EQUAL
          ? compare(na, nb)
          : lineComparison
      }
  }
}

instance Comparable CoverableBranch {
  compare = (a, b) => where(#[a, b]) {
    #[CoverableBranch(la, blockA, branchA), CoverableBranch(lb, blockB, branchB)] =>
      where(#[
        compare(la, lb),
        compare(blockA, blockB),
        compare(branchA, branchB)
      ]) {
        #[-1, _, _] =>
          -1

        #[1, _, _] =>
          1

        #[_, -1, _] =>
          -1

        #[_, 1, _] =>
          1

        #[_, _, -1] =>
          -1

        #[_, _, 1] =>
          1

        _ =>
          0
      }
  }
}


processModuleResult :: String -> CoverageData -> LcovSection
processModuleResult = (modulePath, coverageData) => {
  lineResults = Dictionary.toList(coverageData.coverableLines)
  functionResults = Dictionary.toList(coverageData.coverableFunctions)
  branchResults = Dictionary.toList(coverageData.coverableBranches)

  return {
    ...emptySection,
    sf: SF(modulePath),
    lf: LF(List.length(lineResults)),
    lh: LH(List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, lineResults))),
    das: map(
      where {
        #[CoverableLine(line), hitCounter] =>
          DA(line, hitCounter.read())
      },
      lineResults
    ),
    fnf: FNF(List.length(functionResults)),
    fnh: FNH(List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, functionResults))),
    fns: map(
      where {
        #[CoverableFunction(line, name), _] =>
          FN(line, name)
      },
      functionResults
    ),
    fndas: map(
      where {
        #[CoverableFunction(_, name), hitCounter] =>
          FNDA(hitCounter.read(), name)
      },
      functionResults
    ),
    brdas: map(
      where {
        #[CoverableBranch(line, blockIndex, branchIndex), hitCounter] =>
          BRDA(line, blockIndex, branchIndex, hitCounter.read())
      },
      branchResults
    ),
    brf: BRF(List.length(branchResults)),
    brh: BRH(List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, branchResults))),
  }
}


generateLcov :: Dictionary String CoverageData -> String
generateLcov = (coverablePoints) => pipe(
  Dictionary.toList,
  map(
    where {
      #[modulePath, coverageData] =>
        processModuleResult(modulePath, coverageData)
    }
  ),
  stringify
)(coverablePoints)



// ---------- Coverage Reporter ------------

makeCoverageReporter = () => {
  coverableData :: Dictionary String CoverageData
  coverableData = {{}}

  lineTracker :: String -> Integer -> HitCounter
  lineTracker = (astPath, line) => {
    hitCounter = makeHitCounter(0)
    coverableData = where(Dictionary.get(astPath, coverableData)) {
      Just(coverable) =>
        Dictionary.insert(
          astPath,
          {
            ...coverable,
            coverableLines: Dictionary.insert(
              CoverableLine(line),
              hitCounter,
              coverable.coverableLines
            ),
          },
          coverableData
        )
        
      Nothing =>
        Dictionary.insert(
          astPath,
          {
            coverableLines: {{ CoverableLine(line): hitCounter }},
            coverableFunctions: {{}},
            coverableBranches: {{}},
          },
          coverableData
        )
    }

    return hitCounter
  }

  functionTracker :: String -> Integer -> String -> HitCounter
  functionTracker = (astPath, line, functionName) => {
    hitCounter = makeHitCounter(0)
    coverableData = where(Dictionary.get(astPath, coverableData)) {
      Just(coverable) =>
        Dictionary.insert(
          astPath,
          {
            ...coverable,
            coverableFunctions: Dictionary.insert(
              CoverableFunction(line, functionName),
              hitCounter,
              coverable.coverableFunctions
            ),
          },
          coverableData
        )

      Nothing =>
        Dictionary.insert(
          astPath,
          {
            coverableFunctions: {{ CoverableFunction(line, functionName): hitCounter }},
            coverableLines: {{}},
            coverableBranches: {{}},
          },
          coverableData
        )
    }

    return hitCounter
  }

  branchTracker :: String -> Integer -> Integer -> Integer -> HitCounter
  branchTracker = (astPath, line, blockNumber, branchNumber) => {
    hitCounter = makeHitCounter(0)
    coverableData = where(Dictionary.get(astPath, coverableData)) {
      Just(coverable) =>
        Dictionary.insert(
          astPath,
          {
            ...coverable,
            coverableBranches: Dictionary.insert(
              CoverableBranch(line, blockNumber, branchNumber),
              hitCounter,
              coverable.coverableBranches
            ),
          },
          coverableData
        )

      Nothing =>
        Dictionary.insert(
          astPath,
          {
            coverableBranches: {{ CoverableBranch(line, blockNumber, branchNumber): hitCounter }},
            coverableLines: {{}},
            coverableFunctions: {{}},
          },
          coverableData
        )
    }

    return hitCounter
  }

  generateReport :: a -> {}
  generateReport = () => pipe(
    generateLcov,
    (lcovStr) => do {
      _ <- mapRej(
        () => UnknownError,
        Process.exec("mkdir", ["-p", ".coverage"], Process.DEFAULT_COMMAND_OPTIONS)
      )
      return File.write(".coverage/lcov.info", lcovStr)
    },
    fulfill(() => {}, () => {})
  )(coverableData)

  return { branchTracker, functionTracker, lineTracker, generateReport }
}

export Reporter = makeCoverageReporter()
