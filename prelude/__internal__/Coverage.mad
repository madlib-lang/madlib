import File from "File"
import { UnknownError } from "IOError"
import { fulfill, mapRej } from "Wish"
import Dictionary from "Dictionary"
import List from "List"
import String from "String"
import Tuple from "Tuple"
import Math from "Math"
import { fromMaybe, Just, Nothing } from "Maybe"
import { EQUAL } from "Compare"
import { integerToFloat } from "Number"
// needed as an import is generated in Canonicalize.Coverage
import Process from "Process"
import IO from "IO"


COVERAGE_TEXT = "COVERAGE_TEXT"

alias HitCounter = { increment :: {} -> {}, read :: {} -> Integer }

makeHitCounter :: Integer -> HitCounter
makeHitCounter = (initial) => {
  value = initial

  read :: {} -> Integer
  read = () => value

  increment :: {} -> {}
  increment = () => {
    value = value + 1
  }

  return { increment, read }
}

type CoverableLine = CoverableLine(Integer)
type CoverableFunction = CoverableFunction(Integer, String)
type CoverableBranch = CoverableBranch(Integer, Integer, Integer)

alias CoverageData = {
  coverableLines :: Dictionary CoverableLine HitCounter,
  coverableFunctions :: Dictionary CoverableFunction HitCounter,
  coverableBranches :: Dictionary CoverableBranch HitCounter,
}


// ---------- LCOV ------------

// TN:<test name> usually empty
// SF:<absolute path to the source file>
// FN:<line number of function start>,<function name>
// FNDA:<execution count>,<function name>
// FNF:<number of functions found>
// FNH:<number of function hit>
// BRDA:<line number>,<block number>,<branch number>,<taken>
// BRF:<number of branches found>
// BRH:<number of branches hit>
// DA:<line number>,<execution count>
// LH:<number of lines with a non-zero execution count>
// LF:<number of instrumented lines>
// end_of_record

type LcovLine
  = TN(String)
  | SF(String)
  | FN(Integer, String)
  | FNDA(Integer, String)
  | FNF(Integer)
  | FNH(Integer)
  | DA(Integer, Integer)
  | LF(Integer)
  | LH(Integer)
  | BRF(Integer)
  | BRH(Integer)
  | BRDA(Integer, Integer, Integer, Integer)


alias LcovSection = {
  tn :: LcovLine,
  sf :: LcovLine,
  fns :: List LcovLine,
  fndas :: List LcovLine,
  fnf :: LcovLine,
  fnh :: LcovLine,
  das :: List LcovLine,
  lf :: LcovLine,
  lh :: LcovLine,
  brf :: LcovLine,
  brh :: LcovLine,
  brdas :: List LcovLine,
}

alias LcovInfo = List LcovSection

emptySection :: LcovSection
emptySection = {
  tn: TN(""),
  sf: SF(""),
  fns: [],
  fndas: [],
  fnf: FNF(0),
  fnh: FNH(0),
  das: [],
  lf: LF(0),
  lh: LH(0),
  brf: BRF(0),
  brh: BRH(0),
  brdas: [],
}

stringifyLine :: LcovLine -> String
stringifyLine = (line) => where(line){
  TN(arg) =>
    "TN:" ++ arg ++ "\n"

  SF(arg) =>
    "SF:" ++ arg ++ "\n"

  FN(l, name) =>
    "FN:" ++ inspect(l) ++ "," ++ name ++ "\n"

  FNDA(count, name) =>
    "FNDA:" ++ inspect(count) ++ "," ++ name ++ "\n"

  FNF(count) =>
    "FNF:" ++ inspect(count) ++ "\n"

  FNH(count) =>
    "FNH:" ++ inspect(count) ++ "\n"

  DA(l, count) =>
    "DA:" ++ inspect(l) ++ "," ++ inspect(count) ++ "\n"

  LF(count) =>
    "LF:" ++ inspect(count) ++ "\n"

  LH(count) =>
    "LH:" ++ inspect(count) ++ "\n"

  BRF(count) =>
    "BRF:" ++ inspect(count) ++ "\n"

  BRH(count) =>
    "BRH:" ++ inspect(count) ++ "\n"

  BRDA(l, blockNumber, branchNumber, count) =>
    `BRDA:${inspect(l)},${inspect(blockNumber)},${inspect(branchNumber)},${inspect(count)}\n`
}

stringifySection :: LcovSection -> String
stringifySection = (section) =>
 stringifyLine(section.tn)
 ++ stringifyLine(section.sf)
 ++ List.reduceLeft((fns, line) => fns ++ stringifyLine(line), "", section.fns)
 ++ List.reduceLeft((fndas, line) => fndas ++ stringifyLine(line), "", section.fndas)
 ++ stringifyLine(section.fnf)
 ++ stringifyLine(section.fnh)
 ++ List.reduceLeft((das, line) => das ++ stringifyLine(line), "", section.das)
 ++ stringifyLine(section.lf)
 ++ stringifyLine(section.lh)
 ++ stringifyLine(section.brf)
 ++ stringifyLine(section.brh)
 ++ List.reduceLeft((brdas, line) => brdas ++ stringifyLine(line), "", section.brdas)
 ++ "end_of_record\n"

stringify :: LcovInfo -> String
export stringify = (lcov) => List.reduceLeft((r, section) => r ++ stringifySection(section), "", lcov)


// currently not used, possibly we want to move this to List but because of
// cyclical imports we need to find a solution for private / public modules
// in prelude
groupOn :: Comparable b => (a -> b) -> List a -> List (List a)
groupOn = (f) => {
  unpack = pipe(Dictionary.toList, map(Tuple.snd))
  fld = (m, a) => where(Dictionary.get(f(a), m)) {
    Nothing =>
      Dictionary.insert(f(a), [a], m)

    Just(as) =>
      Dictionary.insert(f(a), [a, ...as], m)
  }

  return pipe(List.reduceLeft(fld, Dictionary.empty), unpack)
}


instance Comparable CoverableLine {
  compare = (a, b) => where(#[a, b]) {
    #[CoverableLine(la), CoverableLine(lb)] =>
      compare(la, lb)
  }
}

instance Comparable CoverableFunction {
  compare = (a, b) => where(#[a, b]) {
    #[CoverableFunction(la, na), CoverableFunction(lb, nb)] =>
      do {
        lineComparison = compare(la, lb)

        return lineComparison == EQUAL
          ? compare(na, nb)
          : lineComparison
      }
  }
}

instance Comparable CoverableBranch {
  compare = (a, b) => where(#[a, b]) {
    #[CoverableBranch(la, blockA, branchA), CoverableBranch(lb, blockB, branchB)] =>
      where(#[
        compare(la, lb),
        compare(blockA, blockB),
        compare(branchA, branchB)
      ]) {
        #[-1, _, _] =>
          -1

        #[1, _, _] =>
          1

        #[_, -1, _] =>
          -1

        #[_, 1, _] =>
          1

        #[_, _, -1] =>
          -1

        #[_, _, 1] =>
          1

        _ =>
          0
      }
  }
}


processModuleResult :: String -> CoverageData -> LcovSection
processModuleResult = (modulePath, coverageData) => {
  lineResults = Dictionary.toList(coverageData.coverableLines)
  functionResults = Dictionary.toList(coverageData.coverableFunctions)
  branchResults = Dictionary.toList(coverageData.coverableBranches)

  return {
    ...emptySection,
    sf: SF(modulePath),
    lf: LF(List.length(lineResults)),
    lh: LH(List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, lineResults))),
    das: map(
      where {
        #[CoverableLine(line), hitCounter] =>
          DA(line, hitCounter.read())
      },
      lineResults
    ),
    fnf: FNF(List.length(functionResults)),
    fnh: FNH(List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, functionResults))),
    fns: map(
      where {
        #[CoverableFunction(line, name), _] =>
          FN(line, name)
      },
      functionResults
    ),
    fndas: map(
      where {
        #[CoverableFunction(_, name), hitCounter] =>
          FNDA(hitCounter.read(), name)
      },
      functionResults
    ),
    brdas: map(
      where {
        #[CoverableBranch(line, blockIndex, branchIndex), hitCounter] =>
          BRDA(line, blockIndex, branchIndex, hitCounter.read())
      },
      branchResults
    ),
    brf: BRF(List.length(branchResults)),
    brh: BRH(List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, branchResults))),
  }
}


dropTestMainData :: List #[String, a] -> List #[String, a]
dropTestMainData = List.filter(
  where {
    #[modulePath, _] =>
      String.takeLast(16, modulePath) != "__TestMain__.mad"
  }
)


keepTwoDecimals :: String -> String
keepTwoDecimals = (input) => pipe(
  String.split("."),
  where {
    [before, after] =>
      if (String.length(after) == 1) {
        before ++ "." ++ after ++ "0"
      } else {
        before ++ "." ++ String.take(2, after)
      }

    [before] =>
      before ++ ".00"
  }
)(input)


type ModuleResult = ModuleResult(String, Float, Float, Float, Float)

buildModuleResult :: String -> CoverageData -> ModuleResult
buildModuleResult = (modulePath, coverageData) => {
  lineResults = Dictionary.toList(coverageData.coverableLines)
  functionResults = Dictionary.toList(coverageData.coverableFunctions)
  branchResults = Dictionary.toList(coverageData.coverableBranches)

  linesFound = List.length(lineResults)
  linesHit = List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, lineResults))

  functionsFound = List.length(functionResults)
  functionsHit = List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, functionResults))

  branchesFound = List.length(branchResults)
  branchesHit = List.length(List.filter(where { #[_, hitCounter] => hitCounter.read() > 0 }, branchResults))

  lineCov = linesFound == 0 ? 100 : linesHit / linesFound * 100
  functionCov = functionsFound == 0 ? 100 : functionsHit / functionsFound * 100
  branchCov = branchesFound == 0 ? 100 : branchesHit / branchesFound * 100
  total = (lineCov + functionCov + branchCov) / 3

  return ModuleResult(modulePath, lineCov, functionCov, branchCov, total)
}


buildAllResults :: Dictionary String CoverageData -> List ModuleResult
buildAllResults = (coverageData) => {
  moduleResults = pipe(
    Dictionary.toList,
    dropTestMainData,
    map(
      where {
        #[modulePath, data] =>
          buildModuleResult(modulePath, data)
      }
    )
  )(coverageData)

  moduleCount = integerToFloat(List.length(moduleResults))

  totalRow = pipe(
    List.reduce(
      (totalResult, moduleResult) => where(#[totalResult, moduleResult]) {
        #[ModuleResult(n, l, f, b, t), ModuleResult(m, ml, mf, mb, mt)] =>
          ModuleResult(n, l + ml, f + mf, b + mb, t + mt)
      },
      ModuleResult("Total", 0, 0, 0, 0)
    ),
    where {
      ModuleResult(n, l, f, b, t) =>
        ModuleResult(n, l / moduleCount, f / moduleCount, b / moduleCount, t / moduleCount)
    }
  )(moduleResults)

  return [...moduleResults, totalRow]
}


printRows :: List (List String) -> {}
printRows = (rows) => {
  finalRows = pipe(
    map(
      where {
        [module, line, fn, branch, total] =>
          `${module} ${line} ${fn} ${branch} ${total}`
      }
    ),
    where {
      [header, ...moduleRows] =>
        [header, String.repeat('-', String.length(header)), ...moduleRows]
    },
    String.join("\n")
  )(rows)

  IO.putLine("\nCoverage")
  IO.putLine("--------\n")
  IO.putLine(finalRows)
  IO.putLine("")
}

formatRows :: List (List String) -> List (List String)
formatRows = (rows) =>
  if (List.isEmpty(rows)) {
    []
  } else {
    do {
      columnCount = pipe(List.nth(0), fromMaybe([]), List.length)(rows)
      colMaxWidths = pipe(
        map(
          (columnIndex) =>
            List.reduce(
              (maxWidth, colContent) => pipe(
                List.nth(columnIndex),
                fromMaybe(""),
                String.length,
                Math.max(maxWidth)
              )(colContent),
              0,
              rows
            )
        )
      )(List.range(0, columnCount))

      return map(
        List.mapWithIndex((colContent, colIndex) => pipe(
          List.nth($, colMaxWidths),
          fromMaybe(0),
          Math.substract($, String.length(colContent)),
          List.repeat(' '),
          String.fromList,
          (spaces) => colContent ++ spaces
        )(colIndex))
      )(rows)
    }
  }


displayCoverageResults :: Dictionary String CoverageData -> {}
displayCoverageResults = (coverageData) => {
  rows = pipe(
    buildAllResults,
    map(
      where {
        ModuleResult(astPath, line, fn, branch, total) =>
          [
            astPath,
            `${keepTwoDecimals(inspect(line))}%`,
            `${keepTwoDecimals(inspect(fn))}%`,
            `${keepTwoDecimals(inspect(branch))}%`,
            `${keepTwoDecimals(inspect(total))}%`,
          ]
      }
    ),
    (rs) => [["Module", "Lines", "Functions", "Branches", "Total"], ...rs],
    formatRows,
    printRows
  )(coverageData)

}


generateLcov :: Dictionary String CoverageData -> String
generateLcov = (coverageData) => pipe(
  Dictionary.toList,
  dropTestMainData,
  map(
    where {
      #[modulePath, data] =>
        processModuleResult(modulePath, data)
    }
  ),
  stringify
)(coverageData)



// ---------- Coverage Reporter ------------

makeCoverageReporter = () => {
  coverageData :: Dictionary String CoverageData
  coverageData = {{}}

  lineTracker :: String -> Integer -> HitCounter
  lineTracker = (astPath, line) => {
    hitCounter = makeHitCounter(0)
    coverageData = where(Dictionary.get(astPath, coverageData)) {
      Just(data) =>
        Dictionary.insert(
          astPath,
          {
            ...data,
            coverableLines: Dictionary.insert(
              CoverableLine(line),
              hitCounter,
              data.coverableLines
            ),
          },
          coverageData
        )
        
      Nothing =>
        Dictionary.insert(
          astPath,
          {
            coverableLines: {{ CoverableLine(line): hitCounter }},
            coverableFunctions: {{}},
            coverableBranches: {{}},
          },
          coverageData
        )
    }

    return hitCounter
  }

  functionTracker :: String -> Integer -> String -> HitCounter
  functionTracker = (astPath, line, functionName) => {
    hitCounter = makeHitCounter(0)
    coverageData = where(Dictionary.get(astPath, coverageData)) {
      Just(data) =>
        Dictionary.insert(
          astPath,
          {
            ...data,
            coverableFunctions: Dictionary.insert(
              CoverableFunction(line, functionName),
              hitCounter,
              data.coverableFunctions
            ),
          },
          coverageData
        )

      Nothing =>
        Dictionary.insert(
          astPath,
          {
            coverableFunctions: {{ CoverableFunction(line, functionName): hitCounter }},
            coverableLines: {{}},
            coverableBranches: {{}},
          },
          coverageData
        )
    }

    return hitCounter
  }

  branchTracker :: String -> Integer -> Integer -> Integer -> HitCounter
  branchTracker = (astPath, line, blockNumber, branchNumber) => {
    hitCounter = makeHitCounter(0)
    coverageData = where(Dictionary.get(astPath, coverageData)) {
      Just(data) =>
        Dictionary.insert(
          astPath,
          {
            ...data,
            coverableBranches: Dictionary.insert(
              CoverableBranch(line, blockNumber, branchNumber),
              hitCounter,
              data.coverableBranches
            ),
          },
          coverageData
        )

      Nothing =>
        Dictionary.insert(
          astPath,
          {
            coverableBranches: {{ CoverableBranch(line, blockNumber, branchNumber): hitCounter }},
            coverableLines: {{}},
            coverableFunctions: {{}},
          },
          coverageData
        )
    }

    return hitCounter
  }

  generateReport :: a -> {}
  generateReport = () => {
    pipe(
      generateLcov,
      (lcovStr) => do {
        _ <- mapRej(
          () => UnknownError,
          Process.exec("mkdir", ["-p", ".coverage"], Process.DEFAULT_COMMAND_OPTIONS)
        )
        return File.write(".coverage/lcov.info", lcovStr)
      },
      fulfill(() => {}, () => {})
    )(coverageData)

    if (Process.getEnv(COVERAGE_TEXT) == Just("ON")) {
      displayCoverageResults(coverageData)
    } else { {} }
  }
  return { branchTracker, functionTracker, lineTracker, generateReport }
}

export Reporter = makeCoverageReporter()
