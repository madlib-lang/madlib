import File from "File"
import { UnknownError } from "IOError"
import { fulfill, mapRej } from "Wish"
import Dictionary from "Dictionary"
import List from "List"
import Tuple from "Tuple"
import { Just, Nothing } from "Maybe"
// needed as an import is generated in Canonicalize.Coverage
import Process from "Process"


type HitPoint
  = FunctionHit(String)
  | LineHit(Integer)
  | BranchHit(Integer, Integer, Integer)

type Coverable
  = CoverableFunction(Integer, String)
  | CoverableLine(Integer)
  | CoverableBranch


isLineHit :: HitPoint -> Boolean
isLineHit = (hp) => where(hp) {
  LineHit(_) =>
    true

  _ =>
    false
}

isCoverableLine :: Coverable -> Boolean
isCoverableLine = (c) => where(c) {
  CoverableLine(_) =>
    true

  _ =>
    false
}


// ---------- LCOV ------------

// TN:<test name> usually empty
// SF:<absolute path to the source file>
// FN:<line number of function start>,<function name>
// FNDA:<execution count>,<function name>
// FNF:<number of functions found>
// FNH:<number of function hit>
// BRDA:<line number>,<block number>,<branch number>,<taken>
// BRF:<number of branches found>
// BRH:<number of branches hit>
// DA:<line number>,<execution count>
// LH:<number of lines with a non-zero execution count>
// LF:<number of instrumented lines>
// end_of_record

type LcovLine
  = TN(String)
  | SF(String)
  | FN(Integer, String)
  | FNDA(Integer, String)
  | FNF(Integer)
  | FNH(Integer)
  | DA(Integer, Integer)
  | LF(Integer)
  | LH(Integer)
  | BRF(Integer)
  | BRH(Integer)
  | BRDA(Integer, Integer, Integer, Integer)


alias LcovSection = {
  tn :: LcovLine,
  sf :: LcovLine,
  fns :: List LcovLine,
  fndas :: List LcovLine,
  fnf :: LcovLine,
  fnh :: LcovLine,
  das :: List LcovLine,
  lf :: LcovLine,
  lh :: LcovLine,
  brf :: LcovLine,
  brh :: LcovLine,
  brdas :: List LcovLine,
}

alias LcovInfo = List LcovSection

emptySection :: LcovSection
emptySection = {
  tn: TN(""),
  sf: SF(""),
  fns: [],
  fndas: [],
  fnf: FNF(0),
  fnh: FNH(0),
  das: [],
  lf: LF(0),
  lh: LH(0),
  brf: BRF(0),
  brh: BRH(0),
  brdas: [],
}

stringifyLine :: LcovLine -> String
stringifyLine = (line) => where(line){
  TN(arg) =>
    "TN:" ++ arg ++ "\n"

  SF(arg) =>
    "SF:" ++ arg ++ "\n"

  FN(l, name) =>
    "FN:" ++ inspect(l) ++ "," ++ name ++ "\n"

  FNDA(count, name) =>
    "FNDA:" ++ inspect(count) ++ "," ++ name ++ "\n"

  FNF(count) =>
    "FNF:" ++ inspect(count) ++ "\n"

  FNH(count) =>
    "FNH:" ++ inspect(count) ++ "\n"

  DA(l, count) =>
    "DA:" ++ inspect(l) ++ "," ++ inspect(count) ++ "\n"

  LF(count) =>
    "LF:" ++ inspect(count) ++ "\n"

 LH(count) =>
    "LH:" ++ inspect(count) ++ "\n"

  BRF(count) =>
    "BRF:" ++ inspect(count) ++ "\n"

  BRH(count) =>
    "BRH:" ++ inspect(count) ++ "\n"

  BRDA(l, blockNumber, branchNumber, count) =>
    `BRDA:${inspect(l)},${inspect(blockNumber)},${inspect(branchNumber)},${inspect(count)}\n`
}

stringifySection :: LcovSection -> String
stringifySection = (section) =>
 stringifyLine(section.tn)
 ++ stringifyLine(section.sf)
 ++ List.reduceLeft((fns, line) => fns ++ stringifyLine(line), "", section.fns)
 ++ List.reduceLeft((fndas, line) => fndas ++ stringifyLine(line), "", section.fndas)
 ++ stringifyLine(section.fnf)
 ++ stringifyLine(section.fnh)
 ++ List.reduceLeft((das, line) => das ++ stringifyLine(line), "", section.das)
 ++ stringifyLine(section.lf)
 ++ stringifyLine(section.lh)
 ++ stringifyLine(section.brf)
 ++ stringifyLine(section.brh)
 ++ List.reduceLeft((brdas, line) => brdas ++ stringifyLine(line), "", section.brdas)
 ++ "end_of_record\n"

stringify :: LcovInfo -> String
export stringify = (lcov) => List.reduceLeft((r, section) => r ++ stringifySection(section), "", lcov)


// currently not used, possibly we want to move this to List but because of
// cyclical imports we need to find a solution for private / public modules
// in prelude
groupOn :: Comparable b => (a -> b) -> List a -> List (List a)
groupOn = (f) => {
  unpack = pipe(Dictionary.toList, map(Tuple.snd))
  fld = (m, a) => where(Dictionary.get(f(a), m)) {
    Nothing =>
      Dictionary.insert(f(a), [a], m)

    Just(as) =>
      Dictionary.insert(f(a), [a, ...as], m)
  }

  return pipe(List.reduceLeft(fld, Dictionary.empty), unpack)
}


instance Comparable Coverable {
  compare = (a, b) => where(#[a, b]) {
    #[CoverableLine(la), CoverableLine(lb)] =>
      compare(la, lb)
  }
}

type CounterCmd
  = READ
  | INCREMENT

alias HitCounter = CounterCmd -> Integer

makeHitCounter :: Integer -> HitCounter
makeHitCounter = (initial) => {
  value = initial

  return (cmd) => where(cmd) {
    READ =>
      value

    INCREMENT =>
      do {
        value = value + 1
        return value
      }
  }
}


processModuleResult :: String -> Dictionary Coverable HitCounter -> LcovSection
processModuleResult = (modulePath, coverablePoints) => {
  lineResults = Dictionary.toList(coverablePoints)

  return {
    ...emptySection,
    sf: SF(modulePath),
    lf: LF(Dictionary.length(coverablePoints)),
    lh: LH(List.length(List.filter(where { #[_, hitCounter] => hitCounter(READ) > 0 }, lineResults))),
    das: map(
      where {
        #[CoverableLine(line), hitCounter] =>
          DA(line, hitCounter(READ))
      },
      lineResults
    )
  }
}


generateLcov :: Dictionary String (Dictionary Coverable HitCounter) -> String
generateLcov = (coverablePoints) => pipe(
  Dictionary.toList,
  map(
    where {
      #[modulePath, coverablePointsForModule] =>
        processModuleResult(modulePath, coverablePointsForModule)
    }
  ),
  stringify
)(coverablePoints)



// ---------- Coverage Reporter ------------

makeCoverageReporter = () => {
  coverablePoints :: Dictionary String (Dictionary Coverable HitCounter)
  coverablePoints = {{}}

  lineTracker :: String -> Integer -> a -> a
  lineTracker = (astPath, line) => {
    ref = makeHitCounter(0)
    coverablePoints = where(Dictionary.get(astPath, coverablePoints)) {
      Just(cps) =>
        Dictionary.insert(astPath, Dictionary.insert(CoverableLine(line), ref, cps), coverablePoints)

      Nothing =>
        Dictionary.insert(astPath, {{ CoverableLine(line): ref }}, coverablePoints)
    }

    return (expResult) => {
      ref(INCREMENT)
      return expResult
    }
  }

  writeLcovFile :: a -> {}
  writeLcovFile = () => pipe(
    generateLcov,
    (lcovStr) => do {
      _ <- mapRej(
        () => UnknownError,
        Process.exec("mkdir", ["-p", ".coverage"], Process.DEFAULT_COMMAND_OPTIONS)
      )
      return File.write(".coverage/lcov.info", lcovStr)
    },
    fulfill(() => {}, () => {})
  )(coverablePoints)

  return { lineTracker, writeLcovFile }
}

export Reporter = makeCoverageReporter()
