import type { Wish } from "Wish"
import { Wish } from "Wish"
import IOError from "IOError"


withColor :: String -> String -> String
withColor = (color, v) => color ++ v ++"\x1b[0m"

export red = withColor("\x1b[31m")
export green = withColor("\x1b[32m")
export yellow = withColor("\x1b[33m")
export grey = withColor("\x1b[90m")

#iftarget js

#-
{Node}
import util from "util"
import readline from "readline"
{/Node}
-#


log :: String -> {}
export log = (a) => #- console.log(a) -#

put :: String -> {}
export put = (a) => #- {
  {Node}
    process.stdout.write(a)
  {/Node}
  {Browser}
    console.log(a)
  {/Browser}
} -#

putLine :: String -> {}
export putLine = log


err :: String -> {}
export err = (e) => #- {
  {Node}
    process.stderr.write(e)
  {/Node}
  {Browser}
    console.error(e)
  {/Browser}
} -#


getLine :: Wish IOError.IOError String
export getLine = Wish((bad, good) => #- {
  {Node}
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: false
    })

    rl.on("line", (line) => {
      rl.close()
      good(line)
    })
  {/Node}
  {Browser}
    bad("Not implemented for browsers!")
  {/Browser}
} -#)

get :: Wish IOError.IOError String
export get = Wish((bad, good) => #- {
  {Node}
    const lines = [];

    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: false
    })

    rl.on("line", (line) => {
      lines.push(line)
    })

    rl.on("close", () => {
      rl.close()
      good(lines.join("\n"))
    })
  {/Node}
  {Browser}
    bad("Not implemented for browsers!")
  {/Browser}
} -#)



export alias Row = { id :: String, cols :: List #[String, String] }

table :: List Row -> a -> a
export table = (rows, a) => (#- {
  const xSpaces = x => new Array(x).fill(' ').join('')

  const longestId = rows.map(x => x.id.length).reduce((a, b) => Math.max(a, b), 0)

  const readyRows = rows
    .map(x => ({ ...x, id: x.id + xSpaces(longestId - x.id.length) }))
    .reduce((rows, row) => {
      return {
        ...rows,
        [row.id]: row.cols.reduce((o, [colName, colValue]) => { o[colName] = colValue; return o; }, {})
      }
    }, {})
  console.table(readyRows)
  return a
} -#)

#elseif llvm

getLineFFI :: (Integer -> String -> {}) -> {}
getLineFFI = extern "madlib__stdio__getLine"

getLine :: Wish IOError.IOError String
export getLine = Wish((bad, good) =>
  getLineFFI(
    (libuvError, line) =>
      libuvError != 0
        ? bad(IOError.fromLibuvError(libuvError))
        : good(line)
  )
)

getFFI :: (Integer -> String -> {}) -> {}
getFFI = extern "madlib__stdio__get"

get :: Wish IOError.IOError String
export get = Wish((bad, good) =>
  getFFI(
    (libuvError, line) =>
      libuvError != 0
        ? bad(IOError.fromLibuvError(libuvError))
        : good(line)
  )
)

log :: String -> {}
export log = extern "puts"

putLine :: String -> {}
export putLine = log

put :: String -> {}
export put = extern "madlib__stdio__put"

err :: String -> {}
export err = extern "madlib__stdio__err"


#endif

errLine :: String -> {}
export errLine = (error) => err(error ++ "\n")

logAndPass :: String -> a -> a
export logAndPass = (v, a) => {
  log(v)
  return a
}

putEmptyLine :: a -> a
export newLine = logAndPass("")

trace :: Inspect a => String -> a -> a
export trace = (v, a) => {
  log(`${v}: ${inspect(a)}`)
  return a
}
