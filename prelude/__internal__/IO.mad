import type { Wish } from "Wish"
import { Wish } from "Wish"
import IOError from "IOError"

import { mapWithIndex } from "List"
import { equals, when } from "Function"
import { split, join, isEmpty } from "String"

END_COLOR = "\x1b[0m"

colorize :: String -> String -> String
colorize = (color, v) => color ++ v ++ END_COLOR

// via https://en.wikipedia.org/wiki/ANSI_escape_code

/**
 * Ansi styles to be used with the ansiColor function.
 *
 * @since 0.11.0
 */
export ansi = {
  FGBlack: "30",
  FGRed: "31",
  FGGreen: "32",
  FGYellow: "33",
  FGBlue: "34",
  FGMagenta: "35",
  FGCyan: "36",
  FGWhite: "37",

  FGBrightBlack: "90",
  FGBrightRed: "91",
  FGBrightGreen: "92",
  FGBrightYellow: "93",
  FGBrightBlue: "94",
  FGBrightMagenta: "95",
  FGBrightCyan: "96",
  FGBrightWhite: "97",

  BGBlack: "40",
  BGRed: "41",
  BGGreen: "42",
  BGYellow: "43",
  BGBlue: "44",
  BGMagenta: "45",
  BGCyan: "46",
  BGWhite: "47",

  BGBrightBlack: "100",
  BGBrightRed: "101",
  BGBrightGreen: "102",
  BGBrightYellow: "103",
  BGBrightBlue: "104",
  BGBrightMagenta: "105",
  BGBrightCyan: "106",
  BGBrightWhite: "107",

  FormatUnderline: "4",
  FormatNoUnderline: "24",
  FormatBold: "1",
  FormatNoBold: "21",

  FormatInvert: "7",
}


/**
 * Adds ansi escape codes to a string given a list of styles.
 *
 * @since 0.11.0
 * @example
 * ansiColor([ansi.FormatBold, ansi.FGBrightRed], "will be red and bold")
 */
ansiColor :: List String -> String -> String
export ansiColor = (parts, str) => colorize(
  `\x1b[${join(";", parts)}m`,
  str
)

export text = {
  black: ansiColor([ansi.FGBlack]),
  red: ansiColor([ansi.FGRed]),
  green: ansiColor([ansi.FGGreen]),
  yellow: ansiColor([ansi.FGYellow]),
  blue: ansiColor([ansi.FGBlue]),
  magenta: ansiColor([ansi.FGMagenta]),
  cyan: ansiColor([ansi.FGCyan]),
  white: ansiColor([ansi.FGWhite]),
  brightBlack: ansiColor([ansi.FGBrightBlack]),
  brightRed: ansiColor([ansi.FGBrightRed]),
  brightGreen: ansiColor([ansi.FGBrightGreen]),
  brightYellow: ansiColor([ansi.FGBrightYellow]),
  brightBlue: ansiColor([ansi.FGBrightBlue]),
  brightMagenta: ansiColor([ansi.FGBrightMagenta]),
  brightCyan: ansiColor([ansi.FGBrightCyan]),
  brightWhite: ansiColor([ansi.FGBrightWhite]),
  underline: ansiColor([ansi.FormatUnderline]),
  bold: ansiColor([ansi.FormatBold]),
  boldUnderline: ansiColor([ansi.FormatBold, ansi.FormatUnderline]),
}

export dark = {
  black: ansiColor([ansi.FGBlack, ansi.BGBlack]),
  red: ansiColor([ansi.FGRed, ansi.BGBlack]),
  green: ansiColor([ansi.FGGreen, ansi.BGBlack]),
  yellow: ansiColor([ansi.FGYellow, ansi.BGBlack]),
  blue: ansiColor([ansi.FGBlue, ansi.BGBlack]),
  magenta: ansiColor([ansi.FGMagenta, ansi.BGBlack]),
  cyan: ansiColor([ansi.FGCyan, ansi.BGBlack]),
  white: ansiColor([ansi.FGWhite, ansi.BGBlack]),
}

export light = {
  black: ansiColor([ansi.FGBrightBlack, ansi.BGWhite]),
  red: ansiColor([ansi.FGBrightRed, ansi.BGWhite]),
  green: ansiColor([ansi.FGBrightGreen, ansi.BGWhite]),
  yellow: ansiColor([ansi.FGBrightYellow, ansi.BGWhite]),
  blue: ansiColor([ansi.FGBrightBlue, ansi.BGWhite]),
  magenta: ansiColor([ansi.FGBrightMagenta, ansi.BGWhite]),
  cyan: ansiColor([ansi.FGBrightCyan, ansi.BGWhite]),
  white: ansiColor([ansi.FGBrightWhite, ansi.BGWhite]),
}


prettyCase :: (String -> String) -> String -> String
prettyCase = (color, str) => pipe(
  (x) => isEmpty(x) ? x : "",
  split(" "),
  mapWithIndex((x, i) => when(
    (_) => equals(i, 0),
    color
  )(x)),
  join(" "),
  (x) => x ++ "\n\t"
)(str)


/**
 * Given a color function and a label it prints the given value with
 * a label colored by the color function.
 *
 * @since 0.11.0
 * @example
 * colortrace(text.green, "label", [1, 2, 3])
 */
colortrace :: Inspect a => (String -> String) -> String -> a -> a
export colortrace = (fn, v, a) => trace(
  prettyCase(fn, v),
  a
)


export red = text.red
export green = text.green
export yellow = text.yellow
export grey = text.white

#iftarget js

#-
{Node}
import util from "util"
import readline from "readline"
{/Node}
-#


/**
 * Writes a string to stdout without line return.
 *
 * @since 0.11.0
 * @example
 * put("Hello world")
 */
put :: String -> {}
export put = (a) => #- {
  {Node}
    process.stdout.write(a)
  {/Node}
  {Browser}
    console.log(a)
  {/Browser}
} -#


/**
 * Writes a string to stdout with line return.
 *
 * @since 0.11.0
 * @example
 * putLine("Hello world")
 */
putLine :: String -> {}
export putLine = (a) => #- { console.log(a) } -#


/**
 * Writes a string to stderr without line return.
 *
 * @since 0.11.0
 * @example
 * err("Hello world")
 */
err :: String -> {}
export err = (e) => #- {
  {Node}
    process.stderr.write(e)
  {/Node}
  {Browser}
    console.error(e)
  {/Browser}
} -#


/**
 * A Wish reading one line from stdin
 *
 * @since 0.11.0
 */
getLine :: Wish IOError.IOError String
export getLine = Wish((bad, good) => #- {
  {Node}
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: false
    })

    rl.on("line", (line) => {
      rl.close()
      good(line)
    })
  {/Node}
  {Browser}
    bad("Not implemented for browsers!")
  {/Browser}
} -#)


/**
 * A Wish reading from stdin
 *
 * @since 0.11.0
 */
get :: Wish IOError.IOError String
export get = Wish((bad, good) => #- {
  {Node}
    const lines = [];

    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: false
    })

    rl.on("line", (line) => {
      lines.push(line)
    })

    rl.on("close", () => {
      rl.close()
      good(lines.join("\n"))
    })
  {/Node}
  {Browser}
    bad("Not implemented for browsers!")
  {/Browser}
} -#)

#elseif llvm

getLineFFI :: (Integer -> String -> {}) -> {}
getLineFFI = extern "madlib__stdio__getLine"


/**
 * A Wish reading one line from stdin
 *
 * @since 0.11.0
 */
getLine :: Wish IOError.IOError String
export getLine = Wish((bad, good) =>
  getLineFFI(
    (libuvError, line) =>
      libuvError != 0
        ? bad(IOError.fromLibuvError(libuvError))
        : good(line)
  )
)


getFFI :: (Integer -> String -> {}) -> {}
getFFI = extern "madlib__stdio__get"


/**
 * A Wish reading from stdin
 *
 * @since 0.11.0
 */
get :: Wish IOError.IOError String
export get = Wish((bad, good) =>
  getFFI(
    (libuvError, line) =>
      libuvError != 0
        ? bad(IOError.fromLibuvError(libuvError))
        : good(line)
  )
)


/**
 * Writes a string to stdout with line return.
 *
 * @since 0.11.0
 * @example
 * putLine("Hello world")
 */
putLine :: String -> {}
export putLine = extern "madlib__stdio__putLine"


/**
 * Writes a string to stdout without line return.
 *
 * @since 0.11.0
 * @example
 * put("Hello world")
 */
put :: String -> {}
export put = extern "madlib__stdio__put"


/**
 * Writes a string to stderr without line return.
 *
 * @since 0.11.0
 * @example
 * err("Hello world")
 */
err :: String -> {}
export err = extern "madlib__stdio__err"


#endif

/**
 * Writes a Madlib value to stdout with line return.
 *
 * @since 0.11.0
 * @example
 * log({ x: 7, y: 13 })
 */
log :: Inspect a => a -> {}
export log = pipe(inspect, putLine)


/**
 * Writes a string to stderr with line return.
 *
 * @since 0.11.0
 * @example
 * errLine("Hello world")
 */
errLine :: String -> {}
export errLine = (error) => err(error ++ "\n")


/**
 * Convenient function to print something in the middle of a pipe.
 * It prints the given string and returns whatever second parameter
 * is given.
 *
 * @since 0.11.0
 * @example
 * putLineAndPass("Something", 3) // 3
 */
putLineAndPass :: String -> a -> a
export putLineAndPass = (v, a) => {
  putLine(v)
  return a
}


/**
 * Convenient function to print a line return.
 *
 * @since 0.11.0
 * @example
 * putEmptyLine(3) // 3
 */
putEmptyLine :: a -> a
export newLine = putLineAndPass("")


/**
 * Very useful within pipes as it allows one to quickly introspect,
 * whatever value is currently coming through the pipe.
 *
 * @since 0.11.0
 * @example
 * // prints "current value 6" and returns 7
 * pipe((x) => x * 2, trace("current value"), (x) => x + 1)(3)
 */
trace :: Inspect a => String -> a -> a
export trace = (v, a) => {
  putLine(`${v} ${inspect(a)}`)
  return a
}
