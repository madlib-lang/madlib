// file: path
let Just = (a => ({ __constructor: "Just", __args: [ a ] }));
let Nothing = ({ __constructor: "Nothing", __args: [  ] });
export let fn = __hpFnWrap('path', 1, 'fn')((b => c => __hpLineWrap('path', 1, __hpLineWrap('path', 1, b)) + __hpLineWrap('path', 1, __hpLineWrap('path', 1, c))));
let inc = __hpFnWrap('path', 3, 'inc')((x => __hpLineWrap('path', 3, __hpLineWrap('path', 3, x)) + __hpLineWrap('path', 3, __hpLineWrap('path', 3, 1))));
let dec = __hpFnWrap('path', 5, 'dec')((x => __hpLineWrap('path', 5, __hpLineWrap('path', 5, x)) - __hpLineWrap('path', 5, __hpLineWrap('path', 5, 1))));
let double = __hpFnWrap('path', 6, 'double')((x => __hpLineWrap('path', 7, __hpLineWrap('path', 7, x)) * __hpLineWrap('path', 7, __hpLineWrap('path', 7, 2))));
let half = __hpFnWrap('path', 9, 'half')((x => __hpLineWrap('path', 9, __hpLineWrap('path', 9, x)) / __hpLineWrap('path', 9, __hpLineWrap('path', 9, 2))));
__hpLineWrap('path', 10, __hpLineWrap('path', 10, double))(__hpLineWrap('path', 10, __hpLineWrap('path', 10, __hpLineWrap('path', 10, half))(__hpLineWrap('path', 10, __hpLineWrap('path', 10, 3)))));
__eq__(__hpLineWrap('path', 11, __hpLineWrap('path', 11, 3)), __hpLineWrap('path', 11, __hpLineWrap('path', 11, 5)));
let carResponse = ({ cars: __hpLineWrap('path', 12, ([])) });
((__x__) => {
  if (__hp('path', 'line', 14, 14) || true) {
    let { cars: cs } = __x__;
    return __hpLineWrap('path', 14, cs);
  }
  else if (__hp('path', 'line', 15, 15) || true) {
    return ([]);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 13, carResponse));
((__x__) => {
  if (__hp('path', 'line', 18, 18) || __x__ === 3) {
    return __hpLineWrap('path', 18, 3);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 17, 3));
((__x__) => {
  if (__hp('path', 'line', 21, 21) || __x__ === "3") {
    return __hpLineWrap('path', 21, 3);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 20, "3"));
((__x__) => {
  if (__hp('path', 'line', 24, 24) || __x__ === true) {
    return __hpLineWrap('path', 24, 3);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 23, true));
let log = __hpFnWrap('path', 27, 'log')((a =>  { console.log(a); return a; } ));
(__hpLineWrap('path', 28, true) ? __hpLineWrap('path', 28, "OK") : __hpLineWrap('path', 28, "NOT OK"));
let mapMaybe = __hpFnWrap('path', 31, 'mapMaybe')((f => m => ((__x__) => {
  if (__hp('path', 'line', 32, 32) || __x__.__constructor === "Just" && true) {
    let a = __x__.__args[0];
    return __hpLineWrap('path', 32, __hpLineWrap('path', 32, Just)(__hpLineWrap('path', 32, __hpLineWrap('path', 32, __hpLineWrap('path', 32, f)(__hpLineWrap('path', 32, __hpLineWrap('path', 32, a)))))));
  }
  else if (__hp('path', 'line', 33, 33) || __x__.__constructor === "Nothing") {
    return __hpLineWrap('path', 33, Nothing);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 31, m))));
let might = __hpLineWrap('path', 35, __hpLineWrap('path', 35, Just)(__hpLineWrap('path', 35, __hpLineWrap('path', 35, 3))));
let q = ((__x__) => {
  if (__hp('path', 'line', 37, 37) || __x__.__constructor === "Just" && true) {
    let a = __x__.__args[0];
    return __hpLineWrap('path', 37, a);
  }
  else if (__hp('path', 'line', 38, 38) || __x__.__constructor === "Nothing") {
    return __hpLineWrap('path', 38, 1);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 36, might));
__hpLineWrap('path', 40, __hpLineWrap('path', 40, true)) && __hpLineWrap('path', 40, __hpLineWrap('path', 40, false));
__hpLineWrap('path', 41, __hpLineWrap('path', 41, false)) || __hpLineWrap('path', 41, __hpLineWrap('path', 41, true));
__hpLineWrap('path', 42, __hpLineWrap('path', 42, false)) || __hpLineWrap('path', 42, __hpLineWrap('path', 42, __hpLineWrap('path', 42, true)) && __hpLineWrap('path', 42, __hpLineWrap('path', 42, false)));
__hpLineWrap('path', 43, __hpLineWrap('path', 43, 1)) > __hpLineWrap('path', 43, __hpLineWrap('path', 43, 3));
__hpLineWrap('path', 44, __hpLineWrap('path', 44, 1)) < __hpLineWrap('path', 44, __hpLineWrap('path', 44, 3));
__hpLineWrap('path', 45, __hpLineWrap('path', 45, __hpLineWrap('path', 45, __hpLineWrap('path', 45, 1)) > __hpLineWrap('path', 45, __hpLineWrap('path', 45, 3))) && __hpLineWrap('path', 45, __hpLineWrap('path', 45, __hpLineWrap('path', 45, 3)) < __hpLineWrap('path', 45, __hpLineWrap('path', 45, 1)))) || __hpLineWrap('path', 45, __hpLineWrap('path', 45, true));
__hpLineWrap('path', 46, __hpLineWrap('path', 46, 1)) >= __hpLineWrap('path', 46, __hpLineWrap('path', 46, 3));
__hpLineWrap('path', 47, __hpLineWrap('path', 47, 1)) <= __hpLineWrap('path', 47, __hpLineWrap('path', 47, 3));
__hpLineWrap('path', 48, __hpLineWrap('path', 48, __hpLineWrap('path', 48, __hpLineWrap('path', 48, 1)) >= __hpLineWrap('path', 48, __hpLineWrap('path', 48, 3))) && __hpLineWrap('path', 48, __hpLineWrap('path', 48, __hpLineWrap('path', 48, 3)) <= __hpLineWrap('path', 48, __hpLineWrap('path', 48, 1)))) || __hpLineWrap('path', 48, __hpLineWrap('path', 48, true));
__hpLineWrap('path', 49, !(__hpLineWrap('path', 49, __hpLineWrap('path', 49, false))));
__hpLineWrap('path', 50, !(__hpLineWrap('path', 50, __hpLineWrap('path', 50, true))));
__hpLineWrap('path', 51, __hpLineWrap('path', 51, !(__hpLineWrap('path', 51, __hpLineWrap('path', 51, false))))) && __hpLineWrap('path', 51, __hpLineWrap('path', 51, !(__hpLineWrap('path', 51, __hpLineWrap('path', 51, true)))));
__hpLineWrap('path', 52, __hpLineWrap('path', 52, !(__hpLineWrap('path', 52, __hpLineWrap('path', 52, false))))) || __hpLineWrap('path', 52, __hpLineWrap('path', 52, !(__hpLineWrap('path', 52, __hpLineWrap('path', 52, true)))));
let arr = ([__hpLineWrap('path', 53, 1), __hpLineWrap('path', 53, 2), __hpLineWrap('path', 53, 3)]);
let all = ([ ...__hpLineWrap('path', 54, arr), __hpLineWrap('path', 54, 4), __hpLineWrap('path', 54, 5), __hpLineWrap('path', 54, 6)]);
((__x__) => {
  if (__hp('path', 'line', 56, 56) || __x__.length === 3 && __x__[0] === 1 && __x__[1] === 2 && __x__[2] === 3) {
    let [,,] = __x__;
    return __hpLineWrap('path', 56, 1);
  }
  else if (__hp('path', 'line', 57, 57) || __x__.length === 3 && __x__[0] === 1 && __x__[1] === 2 && true) {
    let [,,n] = __x__;
    return __hpLineWrap('path', 57, n);
  }
  else if (__hp('path', 'line', 58, 58) || __x__.length === 2 && true && __x__[1] === 3) {
    let [n,] = __x__;
    return __hpLineWrap('path', 58, n);
  }
  else if (__hp('path', 'line', 59, 59) || __x__.length === 3 && true && true && true) {
    let [x1,y1,z1] = __x__;
    return __hpLineWrap('path', 59, __hpLineWrap('path', 59, __hpLineWrap('path', 59, x1)) + __hpLineWrap('path', 59, __hpLineWrap('path', 59, y1))) + __hpLineWrap('path', 59, __hpLineWrap('path', 59, z1));
  }
  else if (__hp('path', 'line', 60, 60) || __x__.length === 0) {
    let [] = __x__;
    return __hpLineWrap('path', 60, 0);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(([__hpLineWrap('path', 55, 1), __hpLineWrap('path', 55, 2), __hpLineWrap('path', 55, 3), __hpLineWrap('path', 55, 5), __hpLineWrap('path', 55, 8)]));
export let map = __hpFnWrap('path', 63, 'map')((f => xs => ((__x__) => {
  if (__hp('path', 'line', 64, 64) || __x__.length === 3 && true && true && true) {
    let [a,b,c] = __x__;
    return ([__hpLineWrap('path', 64, __hpLineWrap('path', 64, f)(__hpLineWrap('path', 64, __hpLineWrap('path', 64, a)))),  ...__hpLineWrap('path', 64, __hpLineWrap('path', 64, __hpLineWrap('path', 64, map)(__hpLineWrap('path', 64, __hpLineWrap('path', 64, f)))(__hpLineWrap('path', 64, ([__hpLineWrap('path', 64, b), __hpLineWrap('path', 64, c)])))))]);
  }
  else if (__hp('path', 'line', 65, 65) || __x__.length === 2 && true && true) {
    let [a,b] = __x__;
    return ([__hpLineWrap('path', 65, __hpLineWrap('path', 65, f)(__hpLineWrap('path', 65, __hpLineWrap('path', 65, a)))),  ...__hpLineWrap('path', 65, __hpLineWrap('path', 65, __hpLineWrap('path', 65, map)(__hpLineWrap('path', 65, __hpLineWrap('path', 65, f)))(__hpLineWrap('path', 65, ([__hpLineWrap('path', 65, b)])))))]);
  }
  else if (__hp('path', 'line', 66, 66) || __x__.length === 1 && true) {
    let [a] = __x__;
    return ([__hpLineWrap('path', 66, __hpLineWrap('path', 66, f)(__hpLineWrap('path', 66, __hpLineWrap('path', 66, a))))]);
  }
  else if (__hp('path', 'line', 67, 67) || __x__.length === 0) {
    let [] = __x__;
    return ([]);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 63, xs))));
(__hpLineWrap('path', 69, true) ? __hpLineWrap('path', 70, "ok") : __hpLineWrap('path', 71, "not ok"));
__hpLineWrap('path', 72, (x => __hpLineWrap('path', 75, x)))(__hpLineWrap('path', 75, __hpLineWrap('path', 72, (x => (__eq__(__hpLineWrap('path', 74, __hpLineWrap('path', 74, x)), __hpLineWrap('path', 74, __hpLineWrap('path', 74, "ok"))) ? __hpLineWrap('path', 74, 1) : __hpLineWrap('path', 74, 10))))(__hpLineWrap('path', 74, __hpLineWrap('path', 72, (x => __hpLineWrap('path', 73, x)))(__hpLineWrap('path', 73, (__eq__(__hpLineWrap('path', 72, __hpLineWrap('path', 72, 1)), __hpLineWrap('path', 72, __hpLineWrap('path', 72, 2))) ? __hpLineWrap('path', 72, "ok") : __hpLineWrap('path', 72, "not ok"))))))));
(__eq__(__hpLineWrap('path', 76, __hpLineWrap('path', 76, 1)), __hpLineWrap('path', 76, __hpLineWrap('path', 76, 2))) ? __hpLineWrap('path', 76, "ok") : __hpLineWrap('path', 76, "not ok"));
((__x__) => {
  if (__hp('path', 'line', 78, 78) || __x__ === 3) {
    return __hpLineWrap('path', 78, 48);
  }
  else if (__hp('path', 'line', 79, 79) || true) {
    let n = __x__;
    return __hpLineWrap('path', 79, (x => __hpLineWrap('path', 79, __hpLineWrap('path', 79, x)) + __hpLineWrap('path', 79, __hpLineWrap('path', 79, 1))))(__hpLineWrap('path', 79, __hpLineWrap('path', 79, 1)));
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 77, 3));
__hpLineWrap('path', 81, (x => __hpLineWrap('path', 84, __hpLineWrap('path', 84, x)) + __hpLineWrap('path', 84, __hpLineWrap('path', 84, 1))))(__hpLineWrap('path', 84, ((__x__) => {
  if (__hp('path', 'line', 82, 82) || __x__ === "3") {
    return __hpLineWrap('path', 82, 48);
  }
  else if (__hp('path', 'line', 83, 83) || true) {
    let n = __x__;
    return __hpLineWrap('path', 83, 1);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 81, "3"))));
__hpLineWrap('path', 85, (x => __hpLineWrap('path', 88, x)))(__hpLineWrap('path', 88, ((__x__) => {
  if (__hp('path', 'line', 86, 86) || __x__.length >= 1 && __x__[0] === 2 && true) {
    let [,...rest] = __x__;
    return __hpLineWrap('path', 86, rest);
  }
  else if (__hp('path', 'line', 87, 87) || __x__.length >= 3 && __x__[0] === 1 && __x__[1] === 2 && __x__[2] === 3 && true) {
    let [,,,...rest] = __x__;
    return __hpLineWrap('path', 87, rest);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(([__hpLineWrap('path', 85, 1), __hpLineWrap('path', 85, 2), __hpLineWrap('path', 85, 3), __hpLineWrap('path', 85, 4), __hpLineWrap('path', 85, 5)]))));
((__x__) => {
  if (__hp('path', 'line', 90, 90) || __x__.name === "Bob") {
    let {  } = __x__;
    return __hpLineWrap('path', 90, "Bob");
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(({ x: __hpLineWrap('path', 89, __hpLineWrap('path', 89, 4)), name: __hpLineWrap('path', 89, __hpLineWrap('path', 89, "John")) }));
let addXAndY = __hpFnWrap('path', 92, 'addXAndY')((r => ((__x__) => {
  if (__hp('path', 'line', 94, 94) || true && true) {
    let { y: y, x: x1 } = __x__;
    return __hpLineWrap('path', 94, __hpLineWrap('path', 94, x1)) + __hpLineWrap('path', 94, __hpLineWrap('path', 94, y));
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 93, r))));
let fnTCHOU = __hpFnWrap('path', 97, 'fnTCHOU')((x => __hpLineWrap('path', 97, __hpLineWrap('path', 97, __hpLineWrap('path', 97, __hpLineWrap('path', 97, __hpLineWrap('path', 97, __hpLineWrap('path', 97, x).a).b).c).d).e)));
let tup = ([__hpLineWrap('path', 99, 1), __hpLineWrap('path', 99, 2), __hpLineWrap('path', 99, 3)]);
__eq__(__hpLineWrap('path', 101, ([__hpLineWrap('path', 101, 1), __hpLineWrap('path', 101, 2), __hpLineWrap('path', 101, 3)])), __hpLineWrap('path', 101, ([__hpLineWrap('path', 101, 1), __hpLineWrap('path', 101, 2), __hpLineWrap('path', 101, 3)])));
((__x__) => {
  if (__hp('path', 'line', 104, 104) || __x__.length === 2 && true && true) {
    let [a,b] = __x__;
    return __hpLineWrap('path', 104, __hpLineWrap('path', 104, a)) + __hpLineWrap('path', 104, __hpLineWrap('path', 104, b));
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(([__hpLineWrap('path', 103, 1), __hpLineWrap('path', 103, 2)]));
let fn2 = __hpFnWrap('path', 108, 'fn2')((a => ([__hpLineWrap('path', 108, a), __hpLineWrap('path', 108, a)])));
let fst = __hpFnWrap('path', 111, 'fst')((tuple => ((__x__) => {
  if (__hp('path', 'line', 112, 112) || __x__.length === 2 && true && true) {
    let [a,] = __x__;
    return __hpLineWrap('path', 112, a);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 111, tuple))));
let snd = __hpFnWrap('path', 115, 'snd')((tuple => {
    let b = ((__x__) => {
  if (__hp('path', 'line', 117, 117) || __x__.length === 2 && true && true) {
    let [,b1] = __x__;
    return __hpLineWrap('path', 117, b1);
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(__hpLineWrap('path', 116, tuple));
    return __hpLineWrap('path', 119, b);
}));
__hpLineWrap('path', 122, __hpLineWrap('path', 122, fst)(__hpLineWrap('path', 122, ([__hpLineWrap('path', 122, 1), __hpLineWrap('path', 122, 2)]))));
__hpLineWrap('path', 123, __hpLineWrap('path', 123, snd)(__hpLineWrap('path', 123, ([__hpLineWrap('path', 123, 1), __hpLineWrap('path', 123, 2)]))));
((__x__) => {
  if (__hp('path', 'line', 125, 125) || __x__.length === 2 && __x__[0].__constructor === "Just" && true && __x__[1].__constructor === "Just" && true) {
    let [{ __args: [n]},{ __args: [m]}] = __x__;
    return __hpLineWrap('path', 125, __hpLineWrap('path', 125, n)) + __hpLineWrap('path', 125, __hpLineWrap('path', 125, m));
  }
  else {
    console.log('non exhaustive patterns for value: ', __x__.toString()); 
    console.trace(); 
    throw 'non exhaustive patterns!';
  }
})(([__hpLineWrap('path', 125, __hpLineWrap('path', 125, Just)(__hpLineWrap('path', 125, __hpLineWrap('path', 125, 3)))), __hpLineWrap('path', 125, __hpLineWrap('path', 125, Just)(__hpLineWrap('path', 125, __hpLineWrap('path', 125, 4))))]));
export default { fn, map };
